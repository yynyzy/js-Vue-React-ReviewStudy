##1.数组去重

①目标:把旧数组里面不重复的元素选取出来放到新数组中,重复的元素只保留一个,放到新数组中去重。
②核心算法:我们遍历旧数组,然后拿着旧数组元素去查询新数组,如果该元素在新数组里面没有出现过,我们就添加,否则不添加。
③我们怎么知道该元素没有存在?利用新数组.indexOf(数组元素)如果返回时-1就说明新数组里面没有改元素
旧数组['c'，'a’,、z'， 'a'， 'x', 'a'，'x’, ‘c'，'b']
新数组[]
解：封装一个函数
 	

```
 function unique(arr) {
        var newArr = [];
        for (var i = 0; i < arr.length; i++) {
            if (newArr.indexOf(arr[i]) === -1) {
                newArr.push(arr[i]);
               }
           }
            return newArr
        }
```



##2.查找字符串某字符出现的位置以及次数
查找字符串”abcoefoxyozzopp"中所有o出现的位置以及次数
核心算法:先查找第一个o出现的位置
然后只要indexOf返回的结果不是-1就继续往后查找
因为indexOf只能查找到第一个，所以后面的查找，一定是当前索引加1，从而继续查找


```
 var str = ”abcoefoxyozzopp";
    var index = str .indexOf('o' );
    var num =0；
    while (index !== -1) {
    	console . log(index);
    	num++；								//统计o出现的次数
    	index = str.indexOf('o', index + 1);
    }
```



##3. 判断字符串中出现次数最多的字符
判断字符串' abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。
//核心算法:利用charAt() 遍历这个字符串
//把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就+1
//遍历对象，得到最大值和该字符
    

```
var str ='abcoefoxyozzopp' ;
    var o ={};
    for(var i = 0;i < str.length; i++) {
    	var chars = str.charAt(i); 			// chars 是字符串的每一个字符
    	if (o[chars]) { 		// o[chars] 得到的是属性值，chars变为属性名												
   			 o[chars]++;} 
   		 else {
    		o[chars] = 1;					//将属性名赋于属性值1
   			 }
    }
    console.1og(0);
		// 2.遍历对象
    var max = 0;
    var ch = ''
    for(var k in o){					
    	if (o[k] > max) {			 		// k得到是属性名
    		max = o[k];						// o[k] 得到的是属性值
    		ch = k;
    	}
    }
    console .1og(max) ;
    console.1og('最多的字符是' + ch); I
    
```


##4.简单的发布留言案例
核心思路︰
点击按钮之后，就动态创建一个li，添加到ul里面。
创建li的同时，把文本域里面的值通过li.innerHTML赋值给li。
如果想要新的留言后面显示就用appendChild如果想要前面显示就用insertBefore。
	

```
<textarea name="" id=''>123</textarea>
	<button>发布</button>
	<ul></ul>
	____<script>____
	// 1．获取元素
    var btn = document.querySelector('button');
    var text = document.querySelector('textarea');
    var ul = document.querySelector('ul');
    // 2．注册事件
    btn.onclick = function() {
    	if (text.value ==''){
   			alert('您没有输入内容');
    		return false;
    	}else{		
   			 var li = document.createElement('li');// 创建元素		
             li.innerHTML = text.value;	 		   //先有li才能赋值	 
   			 ul.insertBefore(li,ul.children[0]);   //添加元素
   			 var as = document.querySelectorAll('a');
             for (var i = 0; i < as.length; i++) {  
                   as[i].onclick = function () {
    // node.removechild(child); 删除的是li 当前a所在的li this.parentNode; 
                    ul.removeChild(this.parentNode);
                 }
             }
         }
    }
```


​    
##5.节点操作-三种动态创建元素区别
    document.write ()
    element .innerHTML,
    document.createElement ()
    区别
    1. document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘
    2. innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘
    3. innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
    4. createElement ()创建多个元素效率稍低一点点，但是结构更清晰


##6.删除事件的两种方式
```
var divs = document.querySelectorAll('div');
	divs[0].onclick = function() {
		alert(11);
// 1．传统方式删除事件
		divs[e].onclick = null;				
		}
//2. removeEventListener 删除事件
    divs[1].addEventListener('click ', fn)		//里面的fn不需要调用加小括号
    function fn() {
   		 alert(22);
   		 divs[1].removeEventListener('click', fn);
    	}
```



##7.阻止事件冒泡的两种方式
事件冒泡∶开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点。
事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。
阻止事件冒泡
标准写法∶利用事件对象里面的stopPropagation ()方法
		e.stopPropagation ()
非标准写法:IE6-8利用事件对象cancelBubble属性

##8.事件委托的原理
不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。

##9定时器开关
```
<button class="begin">开启定时器</button>
<button class="stop">停止定时器</button>
<script>
        var begin = document.querySelector('.begin ');
        var stop = document.querySelector('.stop');
        var timer = null;				//全局变量null是一个空对象
        begin.addEventListener('click ', function() {
        	timer = setInterval(function() {
        		console.log( 'ni hao ma ' );
       		 },1000);
       	 })
        stop.addEventListener('click', function(){
        	clearInterval(timer);
        	}
        )
</script>
```

 ##10.前端渲染和后端渲染的区别





##11.对一个多维数组   深拷贝
JSON.stringify先将obj2对象转化为字符串，再通过JSON.parse转化为对象，JSON.parse会开辟一个新空间来储存，与原来的obj没关系

弊端：对象含有null或正则表达式或日期对象，转化字符串出来是空无法避免。

```
let obj2 = JSON.parse(JSON.stringify(obj))
```







## 12.扩展运算符的浅拷贝

```
let shortcuts = {
    attr1: 3,
    attr2: 4
}
let shortcuts2 = {}
shortcuts2 = {...shortcuts}
```


上面的这种用法实际上相当于是：shortcuts2 = {attr1: 3, attr2: 4}

```
   let a = { x: 1, y: 2 }
   let b = { z: 3 }
   let ab = { ...a, ...b }
   ab // { x: 1, y: 2, z: 3 }
```

以及与shortcuts2 = shortcuts这种直接引用赋值写法的区别。我们知道对于引用类型来说赋值操作其实传递的只是这个对象的地址（粗浅的说），意味着如果按照shortcuts2 = shortcuts的写法的话当改变shortcuts2中的属性的值的话shortcuts也会同样改变。换言之shortcuts和shortcuts2两个变量指向了同一段内存地址。但是如果是 shortcuts2 = { ...shortcuts }，这样的写的话，由于shortcuts中的属性类型都是基本类型，相当于是新建了一个对象，此时改变shortcuts2中的属性值，shortcuts将不受影响——某种意义上实现了对象之间的深拷贝，但是仅限于其属性都为基本类型的情况（或者说只进行了一层的深拷贝）





## 13.对象深拷贝

运用迭代，deep clone函数循环遍历，

特殊情况，递归到 为null或正则表达式或日期对象或非对象，直接将它返回出来。

```
 function deepClone(obj) {
        //=>过滤特殊情况
        if (obj === null) return null;
        if (typeof obj !== "object") return obj;
        if (obj instanceof RegExp) {
            return new RegExp(obj);
        }
        if (obj instanceof Date) {
            return new Date(obj);
        }
        //不直接创建空对象目的:克隆的结果和之前保持相同的所属类
       let newObj = new obj.constructor;
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = deepClone(obj[key]);
            }
        }
        return newObj;
    }


let obj ={
    a:1,    
    b:[2,3,4],
    c:{
        d:5,
       f:6
   }
}

 let r = deepClone(obj)
 console.log(r);
```





# 14.({} + {}).length类型面试题🐕

 

```
const a = ({} + {}).length;
```

  ({}+{}).length 等价于 ({}.toString() + {}.toString() ).length，{}.toString()的值为[object Object]，所以最后结果为30。

  

```
const b = ([] + []).length 
```

// 空数组的length是0

```
 const c = (function () { }).length  
```

Function.length     length 属性指明函数的形参个数。

 

   

```
const d = ([] + {}).length
```

   //实际这两个是不能用操作符"+"的，这个表达式实际是分别调用了[]和{}的toString()方法。[]返回空字符串"",而{}返回"[object Object]",这两个字符串拼在一起刚好是15个字符的一个字符串。

 

```
 const e = [1, 2, 3].map(parseInt)

 console.log(a);  //30
 console.log(b);  //0
 console.log(c);  //0
console.log(d);  //15
console.log(e);  //[1, NaN, NaN
```


1. map函数
 将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 ['1','2','3'].map(parseInt) 就是将字符串1，2，3作为元素；0，1，2作为下标分别调用 parseInt 函数。即分别求出 parseInt('1',0), parseInt('2',1), parseInt('3',2)的结果。


2. parseInt函数（重点）
 概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) //结果为2
 特点：接收两个参数parseInt(string,radix)
    string：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 '2'、'2w'、'2!'
    radix：解析字符串的基数，基数规则如下：
    1）   区间范围介于2~36之间；
    2 ）  当参数为 0，parseInt() 会根据十进制来解析；
    3 ）  如果忽略该参数，默认的基数规则：
 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt("0xf") //15 
 如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt("08")   //8
 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt("88.99f") //88
 只有字符串中的第一个数字会被返回。parseInt("10.33")   //返回10；
 开头和结尾的空格是允许的。parseInt(" 69 10 ")   //返回69
 如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt("f") //返回NaN 而parseInt("f"，16)  //返回15

  三、再来分析一下结果
  ['1','2','3'].map(parseInt)即
 parseInt('1',0);radix 为 0，parseInt() 会根据十进制来解析，所以结果为 1；   
 parseInt('2',1);radix 为 1，超出区间范围，所以结果为 NaN； 
 parseInt('3',2);radix 为 2，用2进制来解析，应以 0 和 1 开头，所以结果为 NaN。

 四、parseInt方法解析的运算过程

```
 parseInt('101.55',10); //以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。  
  parseInt('101',2); //以二进制解析，运算过程：1*2的2次方+0*2的1次方+1*2的0次方=4+0+1=5，结果为 5。
  parseInt('101',8); //以八进制解析，运算过程：1*8的2次方+0*8的1次方+1*8的0次方=64+0+1=65，结果为 65。
  parseInt('101',16); //以十六进制解析，运算过程：1*16的2次方+0*16的1次方+1*16的0次方=256+0+1=257，结果为 257。
```



## 15 阿里题

```
function Foo（） {
getName = functiono{
function getName0{
};
console.log(1);
console.log();
return this;
Foo.getName0;
}
getName0;
FogetName = functiono{
Foo0.getName0;
console,log(2);
getName0;
};
new Foo.getName0;
foprope getName . funcion o(
new Foo0.getName0;
console.log(3);
new new Foo0.getName0;
};
var getName = function 0{
};
console.log(4);
```



## 16面试题

```
    
    //a什么条件下下面成立
    if (a == 1 && a == 2 && a == 3) {
        console.log('条件成立')
    }
    
 一·
     a = {
        i: 0,
        toString() {
            return ++this.i;
       }
    };
    
    二·有问题,要使用proxy 
    var a = 0;
    Object.defineProperty(window, 'a', {
        get() {
            // Uncaught TypeError: Cannot redefine property: a
            // defineProperty GETER拦 截器中不能再次获取当前属性
            return ++a;
        }
    });
    console.log(a);
    
    三·
   vara=[1,2,3];
     a.toString = a. shift
          if(a==1 && a==2 && a==3){
             console.1og('条件成立');
       }

```

## 17模拟实现函数的call、apply、bind方法    

```js
/* 先将传入的指定执行环境的对象 context 取到
将需要执行的方法(调用call的对象) 作为 context 的一个属性方法fn
处理传入的参数， 并执行 context的属性方法fn， 传入处理好的参数
删除私自定义的 fn 属性
返回执行的结果 */

// 模拟 call 方法
Function.prototype.defineCall = function (context) {
    context = context || window;
    context.fn = this; //this指向 sayName函数实例
    let args = [];
    for (let i = 1; i < arguments.length; i++) { //i从1开始 
        args.push(arguments[i]);
    } //或者args = [...arguments].slice(1);
    let result = context.fn(args.join(','));
    delete context.fn;
    return result;
}
let sayName = function (age) {
    console.log('current name: ' + this.name, "current age: " + age);
}
let obj1 = {
    name: "obj's name"
}
sayName.defineCall(obj1, 22); //this指向 sayName函数实例
// current name: obj's name current age: 22


// 模拟 apply 方法
Function.prototype.defineApply = function (context, arr) {
    context = context || window;
    context.fn = this;
    let result;
    if (!arr) { // 第二个参数不传
        result = context.fn();
    } else { // 第二个参数是数组类型
        let args = [];
        for (let i = 0; i < arr.length; i++) { //i从0开始
            args.push(arr[i]);
        }
        result = context.fn(args.join(','));
    }
    delete context.fn;
    return result;
}
let obj2 = {
    name: ['Tom', 'Johy', 'Joe', 'David']
}
sayName.defineApply(obj2, [3, 4, 5, 6, 7]);
// current name: Tom,Johy,Joe,David current age: 3,4,5,6,7


//用call、apply模拟实现bind
Function.prototype.mybind = function (context) {
    let self = this; // 保存函数的引用
    return function () {
        // 返回一个新的函数
        // console.log(arguments);
        // return self.apply(context, arguments);
        return self.call(context, arguments);
    }
};

let obj = {
    name: 'seven'
}

let func = function () {
    console.log(this.name)
}.bind(obj);
func('zhangsan', 20);
```

## 18模拟实现函数节流、防抖方法   

```
function debounce(fn, delay) {//防抖
  // 维护一个 timer，用来记录当前执行函数状态
  let timer = null;

  return function() {
    // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量
    let context = this;
    let args = arguments;
    // 清理掉正在执行的函数，并重新执行
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, delay);
  }
}
let flag = 0; // 记录当前函数调用次数
// 当用户滚动时被调用的函数
function foo() {
  flag++;
  console.log('Number of calls: %d', flag);
}

// 在 debounce 中包装我们的函数，过 2 秒触发一次
document.body.addEventListener('scroll', debounce(foo, 2000));

function throttle(func, delay){//节流
  let timer = null;

  return function(){
    let context = this;
    let args    = arguments;
    if(!timer){
      timer = setTimeout(function(){
        func.apply(context, args);
        timer = null;
      }, delay);
    }
  }
}
```

## 19模拟实现对象的深拷贝  

```
//第一种：JSON.parse(JSON.stringify())方法实现深拷贝

var obj={
	a:"hello",
	b:1,
	c:true,
	d:[1,2],
	e:{x:1,y:2},
	f:function(){
		console.log("copytest");
	},
	g:null,
	h:undefined
};
var copyobj=JSON.parse(JSON.stringify(obj));

console.log(copyobj);
copyobj.a="change";
copyobj.d[0]=9;
copyobj.e.x=8;
console.log(obj);


//第二种：递归的方法实现深拷贝
function deepclone(obj,copyobj){
    var copyobj=copyobj||{};
    for (var keys in obj) { //使用for..in进行遍历   数组的话keys为0,1..... keys是string类型
        if(obj.hasOwnProperty(keys)){//剥离原型链的数据
            if((typeof(obj[keys])) ==='object' && obj[keys]!==null){//判断是否为引用数据类型
                if (Object.prototype.toString.call(obj[keys]) === '[object Array]') { //Object原型方法得到类型
                    copyobj[keys]=[];
                }else{
                    copyobj[keys]={};
                }
                deepclone(obj[keys],copyobj[keys]);
            }else{
                copyobj[keys]=obj[keys];
            }
        }
    }
    return copyobj;
}
```

## 20嵌套数组指定层次展开 flat扁平化（多种方法，至少掌握两种）

```
// 嵌套数组指定层次展开   flat扁平化
// 1. 普通方法 递归
function flattenMd() {
    let result = []
    return function flatten(arr) {//闭包
        arr.forEach(item => {
            if (Array.isArray(item)) {
                flatten(item)
            } else {
                result.push(item)
            }
        })
        return result
    }
}
// var ary = [1, [2, [3, [4, 5]]], 6]
// flattenMd()(ary);  函数柯里化  部分求值

//2.concat  与方法1类似 没用闭包
function flattenMd(arr) {
    let result = [] // 利用函数作用域保存result var result = []也可
    arr.forEach(item => {
        if (Array.isArray(item)) {
            result = result.concat(flattenMd(item))
        } else {
            result.push(item)
        }
    })
    return result
}

//3. reduce 
function flattenMd(arr) { //.concat([3,4])和.concat(3,4)均可
    return arr.reduce((prev, item) => prev.concat(Array.isArray(item) ? flattenMd(item) : item), [])
}

// 4. 展开运算符
function flattenMd(arr) {
    let flatten = arr => [].concat(...arr)//可去掉一层[]
    return flatten(arr.map(item => Array.isArray(item) ? flattenMd(item) : item))
}

// 5. join和split组合（ 只适用字符串数组， 最简单粗暴）
//[ '1', '2', '3', '4', '5', '6' ] 得到的是字符串数组  再转换一下才行
function flattenMd(arr) {
    return arr.join().split(',')
    //join() 方法用于把数组中的所有元素放入一个字符串 默认用,隔开
}
```

## 21模拟实现 reduce 数组方法   

```
//reduce（）函数接受两个参数，一个函数一个累积变量的初始值。
//函数有四个参数：累计变量初值（默认第一个成员），当前变量值（默认第二个成员），当前位置，数组自身。
//arr.reduce(function(prev, cur, index, arr){}, initialValue)
Array.prototype.myReduce=function(fn,base){
    if(typeof fn !== 'function'){
        throw new TypeError("arguments[0] is not a function");//TypeError是错误的类型之一：类型错误
    }

    var initialArr=this;//调用myReduce()函数的当前对象
    var arr=initialArr.concat();//目的是返回一个等于初始数组的新数组，后面的操作都基于arr，这样初始数组不会发生改动
    var index,newValue;
    
    if(arguments.length==2){
        arr.unshift(base);
        index = 0; //！！当前位置 指的是当前变量（第二个参数）针对调用该方法的数组位置即initialArr
    }else{
        index=1;
    }

    if(arr.length===1){//长度为1 直接返回
        newValue=arr[0];
    }

    while(arr.length>1){
        newValue=fn.call(null,arr[0],arr[1],index,initialArr);
        index++;
        arr.splice(0,2,newValue);//删除前两位 然后把累加值添加到第一位
    }
    return newValue;
};
```

##22.模拟实现数组map方法 

```
// 模拟实现map
// arr.map(function (currentValue, index, arr) {
// })
// currentValue 必须。 当前元素的值
// index 可选。 当期元素的索引值
// arr 可选。 当期元素属于的数组对象

Array.prototype.newMap = function (fn) { //写法一
    var newArr = [];
    for (var i = 0; i < this.length; i++) {
        newArr.push(fn(this[i], i, this)) //this指向调用newMap方法的数组
    }
    return newArr;
}

// arr.reduce((previousValue, currentValue, currentIndex, array) => {}, initialValue？)
// reduce若不指定初始值， 那么第一次迭代的 previousValue 为 ar[[0], currentValue 为 arr[1], currentIndex 为 1，
// 若指定初始值， 那么第一次迭代的 previousValue 为 initialValue, currentValue为 arr[0], currentIndex 为0.

Array.prototype.newMap = function (fn, Arg) { ////写法二：用数组的reduce方法实现数组的map
    var res = [];
    this.reduce((prev, curr, index, array) => {
        res.push(fn.call(Arg, curr, index, array));
    }, 0) //指定初始值initialValue=0，所以从currentIndex=0开始，即第一个开始  不这样会缺第一项，结果为[3,4]
    return res;
}


let arr = [1, 2, 3];
let res = arr.newMap((a) => a + 1);
console.log(res); //[2,3,4]
```



##23.array.fill(value, start, end)     

 value 必需。填充的值。start 可选。开始填充位置。end 可选。停止填充位置 (默认为 array.length)

```
Array.prototype.myFill = function (value, start = 0, end = this.length) {
    for (let i = start; i < end; i++) {
        this[i] = value;
    }
}
```



##24.    Array.find()         
      用于找出第一个符合条件的数组成员，参数为一个回调函数         
      [1, 4, -5, 10].find((n) => n < 0) // -5

```
Array.prototype.myFind = function (fn, start = 0, end = this.length) {
    for (let i = start; i < end; i++) {
        if (fn.call(this, this[i], i, this)) {
            return this[i]
        }
    }
}
```

25.模拟实现Promise.all方法(Promise.race也需要了解) 

```
 //promise.all()
  function myall(proArr) {
    return new Promise((resolve, reject) => {
      let ret = []
      let count = 0
      let done = (i, data) => {
        ret[i] = data
        if(++count === proArr.length) resolve(ret)
      }
      for (let i = 0; i < proArr.length; i++) {
        proArr[i].then(data => done(i,data) , reject)
      }
    })
  }
  
  
//promise.race();这么简单得益于promise的状态只能改变一次，即resolve和reject都只被能执行一次
 function myrace(proArr) {
    return new Promise(function (resolve, reject) {
      for(let i=0;i<proArr.length;i++){
        proArr[i].then(resolve,reject);
      }
    })
  }
```

##26.使用原生的实现ajax请求 

```
//手写3遍以上
var xhr = new XMLHttpRequest();// 创建XMLHttqRequest
var url = 'https://bbin.com';
xhr.onreadystatechange=function(){// 监听状态码的变化，每次变化 均执行
    if(xhr.readyState===4){

        if (xhr.status === 200) { // 服务端 状态码
            console.log(xhr.responseText); //服务器返回的响应文本
        }else{
            console.error(xhr.statusText); //状态码的文本描述，如200的statusText是ok
        }
    
    }
}

xhr.open('GET', url, true); // 初始化请求参数，还没发送请求   true表示异步
xhr.send(null); // 向服务器发送请求,但是不带有数据发送过去,一般在get方式发送时候多使用这个方式
```

##27.模拟实现构造函数new的过程 

```
function myNew(constructor,params){
  var args = [].slice.call(arguments);
  var constructor = args.shift();
  var obj = new Object();
  obj.__proto__ = constructor.prototype;
  var res = constructor.apply(obj,args);
  return (typeof res === 'object' && typeof res !== null) ? res : obj;
}
```

##28.模拟实现Object.create方法  

```
// 用于创建一个新对象,被创建的对象继承另一个对象(o)的原型
function createObj(o) {//传入的参数o为返回实例的__porto__,也就是实例构造函数的显示原型
    function F() {}//构造函数
    F.prototype = o;
    return new F();//返回实例
}
```

##29.模拟实现instanceof的功能 

```
function instanceofObj(a, b) {
    // 模拟 a instanceof b
    let prototypeB = b.prototype;
    let protoA = a.__proto__;
    let state = false;
    while (true) {
        if (protoA == null) { // 可能是 undefined 
            state = false;
            break;
        }
        if (prototypeB === protoA) {
            state = true;
            break;
        }
        protoA = protoA.__proto__;
    }
    return state;
}
console.log(instanceofObj([], Array));
instanceofObj([], Array); //true
```

##30使用setTimeout实现setInterval方法 

```
function mysetinterval(fn,time){
    console.log("利用steTimeout实现setInterval");
    function interval(){//执行该函数，异步被挂起time时间后在执行，一上来就执行fn
        setTimeout(interval,time);//异步
        //好，time时间过去，这个异步被执行，而内部执行的函数正是interval，就相当于进了一个循环，递归
        fn();//同步
    }
    setTimeout(interval,time);//interval被延迟time时间执行
}
```

##31js实现观察者模式 

```
//ES6 实现观察者模式代码：（观察订阅模式）
const queuedObservers = new Set();
const observe = fn => queuedObservers.add(fn); // 依赖收集  Vue中的dep
const observable = obj => new Proxy(obj, {set});// Proxy和Reflect一一对应
function set(target, key, value, receiver){
    const result = Reflect.set(target, key, value, receiver); // 执行set
    queuedObservers.forEach(observe => observe()); // 派发更新
    return result;
}

// 使用 观察者模式实例
const person = observable({
    name: 'Sun',
    age: 30
});

function print(){
    console.log(`name: ${person.name}, age: ${person.age}`);
}
observe(print);

person.age = 31;
// name: Sun, age: 31 、
```





## 32**问题描述**

　　最近在上线新版本项目的时候，发现有的用户的操作还是调用的老版本JS里面的内容，这样就造成原来新的JS里面加上的限制不能限制用户的操作，从而导致用户可以重复操作。

**问题产生原因**

　　如果在用户之前已经访问过系统，那么浏览器中会缓存该系统的CSS、JS，这些CSS、JS缓存未过期之前，浏览器只会从缓存中读取CSS和JS，如果在服务器上修改了css和js，那么这些修改在用户的浏览器中是不会有变化的。

**解决方案**

解决方式一：

用户按Ctrl + F5强制刷新页面或者手动清空了浏览器的缓存。此时浏览器会重新向服务器获取CSS和JS文件,新的文件便会生效。

解决方式二：

​       但是用户量过大的时候总不能让每个用户一一清理缓存吧，于是便从代码的角度着手解决这个问题。在js后面添加版本号，让浏览器把这个JS文件当做新的文件重新向服务器获取资源。

加版本号之前：

```
<script type="text/javascript" th:src="@{/js/test/index.js}"></script>
```

加版本号之后：

```
<script type="text/javascript" th:src="@{/js/test/index.js?v=1.0}"></script>
```

此时问题解决，CSS与上类似。

问题延伸：

   但是JS文件或CSS过多的情况下需要一个一个的去修改版本号，会花费大量的时间，这个时候需要怎么操作呢？？？

 

<script type="text/javascript" src="/js/common.js?t={{date("Y-m-d")}}" ></script> 使用日期，重新请求服务器。

<script type="text/javascript" src="/js/common.js?t={{time()}}" ></script> 使用时间戳
<script type="text/javascript" >loadJs("http://localhost:8081/static/html/convention.js.js?timestamp="+Math.random(),null);</script>

 



## 33按照如下要求实现 process ⽅法

- 取得两个数组⾥相同的部分, 并去重
- 然后按照从⼩到⼤顺序排序, 最后结果返回 (注意, 是返回结果, 不是把结果打印出来)

```
const arrayA = [4, 2, 1, 2, 5];
const arrayB = [2, 3, 1, 6];
function process(arrayA, arrayB) {
// 这⾥是你实现代码的地⽅
}
/*
应该返回 [1, 2]
*/
process(arrayA, arrayB);
复制代码
```

#### 作答部分

第一种：

```
function process(arrayA, arrayB){
  return arrayA
    .filter((v) => arrayB.includes(v))
    .filter((v, i, arr) => arr.indexOf(v) === i )
    .sort((a, b) => a-b);
}
复制代码
```

第⼆种：

```
function process(arrayA, arrayB) {
  const set = new Set();
  while(arrayA.length > 0) {
    const ele = arrayA.pop();
    if (arrayB.includes(ele)) {
      set.add(ele);
    }
  }
  return [...set].sort((a,b) => a - b);
}
```

 

 

 

 