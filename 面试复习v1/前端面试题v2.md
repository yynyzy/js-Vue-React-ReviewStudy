## 1.数组去重

①目标:把旧数组里面不重复的元素选取出来放到新数组中,重复的元素只保留一个,放到新数组中去重。
②核心算法:我们遍历旧数组,然后拿着旧数组元素去查询新数组,如果该元素在新数组里面没有出现过,我们就添加,否则不添加。
③我们怎么知道该元素没有存在?利用新数组.indexOf(数组元素)如果返回时-1就说明新数组里面没有改元素
旧数组['c'，'a’,、z'， 'a'， 'x', 'a'，'x’, ‘c'，'b']
新数组[]
解：封装一个函数
 	

```js
 function unique(arr) {
        var res = [];
        for (var i = 0; i < arr.length; i++) {
            if (res.indexOf(arr[i]) === -1) {
                res.push(arr[i]);
               }
           }
            return res
        }
```



## 2.查找字符串某字符出现的位置以及次数
查找字符串”abcoefoxyozzopp"中所有o出现的位置以及次数
核心算法:先查找第一个o出现的位置
然后只要indexOf返回的结果不是-1就继续往后查找
因为indexOf只能查找到第一个，所以后面的查找，一定是当前索引加1，从而继续查找


```js
 var str = ”abcoefoxyozzopp";
    var index = str .indexOf('o' );
    var num =0；
    while (index !== -1) {
    	console.log(index);
    	num++；								//统计o出现的次数
    	index = str.indexOf('o', index + 1);
    }
```



## 3. 判断字符串中出现次数最多的字符
判断字符串' abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。
//核心算法:利用charAt() 遍历这个字符串
//把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就+1
//遍历对象，得到最大值和该字符  

```js
var str ='abcoefoxyozzopp' ;
    var o ={};
    for(var i = 0;i < str.length; i++) {
    	var chars = str.charAt(i); 			// chars 是字符串的每一个字符
    	if (o[chars]) { 		// o[chars] 得到的是属性值，chars变为属性名												
   			 o[chars]++;} 
   		 else {
    		o[chars] = 1;					//将属性名赋于属性值1
   			 }
    }
    console.1og(0);
		// 2.遍历对象
    var max = 0;
    var ch = ''
    for(var k in o){					
    	if (o[k] > max) {			 		// k得到是属性名
    		max = o[k];						// o[k] 得到的是属性值
    		ch = k;
    	}
    }
    console .1og(max) ;
    console.1og('最多的字符是' + ch); I
    
```


## 4.简单的发布留言案例
核心思路︰
点击按钮之后，就动态创建一个li，添加到ul里面。
创建li的同时，把文本域里面的值通过li.innerHTML赋值给li。
如果想要新的留言后面显示就用appendChild如果想要前面显示就用insertBefore。
	
```js
<textarea name="" id=''>123</textarea>
	<button>发布</button>
	<ul></ul>
	____<script>____
	// 1．获取元素
    var btn = document.querySelector('button');
    var text = document.querySelector('textarea');
    var ul = document.querySelector('ul');
    // 2．注册事件
    btn.onclick = function() {
    	if (text.value ==''){
   			alert('您没有输入内容');
    		return false;
    	}else{		
   			 var li = document.createElement('li');// 创建元素		
             li.innerHTML = text.value;	 		   //先有li才能赋值	 
   			 ul.insertBefore(li,ul.children[0]);   //添加元素
   			 var as = document.querySelectorAll('a');
             for (var i = 0; i < as.length; i++) {  
                   as[i].onclick = function () {
    // node.removechild(child); 删除的是li 当前a所在的li this.parentNode; 
                    ul.removeChild(this.parentNode);
                 }
             }
         }
    }
```


​    

## 5.节点操作-三种动态创建元素区别
    document.write ()
    element .innerHTML,
    document.createElement ()
    区别
    1. document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘
    2. innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘
    3. innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
    4. createElement ()创建多个元素效率稍低一点点，但是结构更清晰


## 6.删除事件的两种方式
```js
var divs = document.querySelectorAll('div');
	divs[0].onclick = function() {
		alert(11);
// 1．传统方式删除事件
		divs[e].onclick = null;				
		}
//2. removeEventListener 删除事件
    divs[1].addEventListener('click ', fn)		//里面的fn不需要调用加小括号
    function fn() {
   		 alert(22);
   		 divs[1].removeEventListener('click', fn);
    	}
```



## 7.阻止事件冒泡的两种方式
事件冒泡∶开始时由最具体的元素接收，然后逐级向上传播到到DOM最顶层节点。
事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。
阻止事件冒泡
标准写法∶利用事件对象里面的stopPropagation ()方法
		e.stopPropagation ()
非标准写法:IE6-8利用事件对象cancelBubble属性

## 8.事件委托的原理
不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。

## 9.定时器开关
```js
<button class="begin">开启定时器</button>
<button class="stop">停止定时器</button>
<script>
        var begin = document.querySelector('.begin ');
        var stop = document.querySelector('.stop');
        var timer = null;				//全局变量null是一个空对象
        begin.addEventListener('click ', function() {
        	timer = setInterval(function() {
        		console.log( 'ni hao ma ' );
       		 },1000);
       	 })
        stop.addEventListener('click', function(){
        	clearInterval(timer);
        	}
        )
</script>
```

 ## 10.前端渲染和后端渲染的区别

## 11.对一个多维数组深拷贝
JSON.stringify先将obj2对象转化为字符串，再通过JSON.parse转化为对象，JSON.parse会开辟一个新空间来储存，与原来的obj没关系

弊端：对象含有null或函数或正则表达式或日期对象，转化字符串出来是空无法避免。

```js
let obj2 = JSON.parse(JSON.stringify(obj))
```







## 12.扩展运算符的浅拷贝

```js
let shortcuts = {
    attr1: 3,
    attr2: 4
}
let shortcuts2 = {}
shortcuts2 = {...shortcuts}
```


上面的这种用法实际上相当于是：shortcuts2 = {attr1: 3, attr2: 4}
```js
   let a = { x: 1, y: 2 }
   let b = { z: 3 }
   let ab = { ...a, ...b }
   ab // { x: 1, y: 2, z: 3 }
```
shortcuts2 = { ...shortcuts }，这样的写的话，由于shortcuts中的属性类型都是基本类型，相当于是新建了一个对象，此时改变shortcuts2中的属性值，shortcuts将不受影响——某种意义上实现了对象之间的深拷贝，但是仅限于其属性都为基本类型的情况（或者说只进行了一层的深拷贝）





## 13.对象深拷贝

运用迭代，deep clone函数循环遍历，
特殊情况，递归到 为null或正则表达式或日期对象或非对象，直接将它返回出来。

```js
 function deepClone(obj) {
        //=>过滤特殊情况
        if (obj === null) return null;
        if (typeof obj !== "object") return obj;
        if (obj instanceof RegExp) {
            return new RegExp(obj);
        }
        if (obj instanceof Date) {
            return new Date(obj);
        }
        //不直接创建空对象目的:克隆的结果和之前保持相同的所属类
       let newObj = new obj.constructor;
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = deepClone(obj[key]);
            }
        }
        return newObj;
    }


let obj ={
    a:1,    
    b:[2,3,4],
    c:{
        d:5,
       f:6
   }
}

 let r = deepClone(obj)
 console.log(r);
```





## 14.({} + {}).length类型面试题🐕

```js
const a = ({} + {}).length;
```
  ({}+{}).length 等价于 ({}.toString() + {}.toString() ).length，{}.toString()的值为[object Object]，所以最后结果为30。

  
```js
const b = ([] + []).length 
```
空数组的length是0

```js
 const c = (function () { }).length  
```
Function.length     length 属性指明函数的形参个数。


```js
const d = ([] + {}).length
```
   //实际这两个是不能用操作符"+"的，这个表达式实际是分别调用了[]和{}的toString()方法。[]返回空字符串"",而{}返回"[object Object]",这两个字符串拼在一起刚好是15个字符的一个字符串。


```js
 const e = [1, 2, 3].map(parseInt)
console.log(e);  //[1, NaN, NaN]
```


1. map函数
 将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 ['1','2','3'].map(parseInt) 就是将字符串1，2，3作为元素；0，1，2作为下标分别调用 parseInt 函数。即分别求出 parseInt('1',0), parseInt('2',1), parseInt('3',2)的结果。


2. parseInt函数（重点）
 概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) //结果为2
 特点：接收两个参数parseInt(string,radix)
    string：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 '2'、'2w'、'2!'
    radix：解析字符串的基数，基数规则如下：
    1）   区间范围介于2~36之间；
    2 ）  当参数为 0，parseInt() 会根据十进制来解析；
    3 ）  如果忽略该参数，默认的基数规则：
 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt("0xf") //15 
 如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt("08")   //8
 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt("88.99f") //88
 只有字符串中的第一个数字会被返回。parseInt("10.33")   //返回10；
 开头和结尾的空格是允许的。parseInt(" 69 10 ")   //返回69
 如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt("f") //返回NaN 而parseInt("f"，16)  //返回15

  三、再来分析一下结果
  ['1','2','3'].map(parseInt)即
 parseInt('1',0);radix 为 0，parseInt() 会根据十进制来解析，所以结果为 1；   
 parseInt('2',1);radix 为 1，超出区间范围，所以结果为 NaN； 
 parseInt('3',2);radix 为 2，用2进制来解析，应以 0 和 1 开头，所以结果为 NaN。

 四、parseInt方法解析的运算过程

```
 parseInt('101.55',10); //以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。  
  parseInt('101',2); //以二进制解析，运算过程：1*2的2次方+0*2的1次方+1*2的0次方=4+0+1=5，结果为 5。
  parseInt('101',8); //以八进制解析，运算过程：1*8的2次方+0*8的1次方+1*8的0次方=64+0+1=65，结果为 65。
  parseInt('101',16); //以十六进制解析，运算过程：1*16的2次方+0*16的1次方+1*16的0次方=256+0+1=257，结果为 257。
```



## 15 阿里题

```js
function Foo（） {
    getName = functiono{
    function getName0{
    };
    console.log(1);
    console.log();
    return this;
    Foo.getName0;
}
getName0;
FogetName = functiono{
Foo0.getName0;
console,log(2);
getName0;
};
new Foo.getName0;
foprope getName . funcion o(
new Foo0.getName0;
console.log(3);
new new Foo0.getName0;
};
var getName = function 0{
};
console.log(4);
```



## 16面试题
```js
    //a什么条件下下面成立
    if (a == 1 && a == 2 && a == 3) {
        console.log('条件成立')
    }
    
 一·
     a = {
        i: 0,
        toString() {
            return ++this.i;
       }
    };
    
二·有问题,要使用proxy 
    var a = 0;
    Object.defineProperty(window, 'a', {
        get() {
            // Uncaught TypeError: Cannot redefine property: a
            // defineProperty GETER拦 截器中不能再次获取当前属性
            return ++a;
        }
    });
    console.log(a);
    
    三·
   var a =[1,2,3];
     a.toString = a. shift
          if(a==1 && a==2 && a==3){
             console.1og('条件成立');
       }

```






## 32**问题描述**

最近在上线新版本项目的时候，发现有的用户的操作还是调用的老版本JS里面的内容，这样就造成原来新的JS里面加上的限制不能限制用户的操作，从而导致用户可以重复操作。

**问题产生原因**

如果在用户之前已经访问过系统，那么浏览器中会缓存该系统的CSS、JS，这些CSS、JS缓存未过期之前，浏览器只会从缓存中读取CSS和JS，如果在服务器上修改了css和js，那么这些修改在用户的浏览器中是不会有变化的。

**解决方案**

解决方式一：

用户按Ctrl + F5强制刷新页面或者手动清空了浏览器的缓存。此时浏览器会重新向服务器获取CSS和JS文件,新的文件便会生效。

解决方式二：

但是用户量过大的时候总不能让每个用户一一清理缓存吧，于是便从代码的角度着手解决这个问题。在js后面添加版本号，让浏览器把这个JS文件当做新的文件重新向服务器获取资源。

加版本号之前：

```
<script type="text/javascript" th:src="@{/js/test/index.js}"></script>
```

加版本号之后：

```
<script type="text/javascript" th:src="@{/js/test/index.js?v=1.0}"></script>
```

此时问题解决，CSS与上类似。

问题延伸：

   但是JS文件或CSS过多的情况下需要一个一个的去修改版本号，会花费大量的时间，这个时候需要怎么操作呢？？？

 

<script type="text/javascript" src="/js/common.js?t={{date("Y-m-d")}}" ></script> 使用日期，重新请求服务器。

<script type="text/javascript" src="/js/common.js?t={{time()}}" ></script> 使用时间戳
<script type="text/javascript" >loadJs("http://localhost:8081/static/html/convention.js.js?timestamp="+Math.random(),null);</script>

 





 

 

 

 