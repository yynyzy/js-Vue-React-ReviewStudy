# HTTP 1.1
·HTTP 1.1 使用了摘要算法来进行身份验证
·HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据。长连接的连接时长可以通过请求头中的 keep-alive 来设置
·HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制 缓存失效。
·HTTP 1.1 支持断点续传，通过使用请求头中的 Range 来实现。
·HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
·HTTP/1.1管线化可以支持请求并发
缺点：
  ·线头阻塞：TCP每次连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
  ·虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个·TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。
  ·头部冗余，采用文本格式HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
  ·客户端需要主动请求

# HTTP 2.0
·头部压缩，由于 HTTP 1.1 经常会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导 致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
·二进制格式，采用二进制格式而非文本模式，提升了解析效率，数据更紧凑，减少错误
·强化安全， HTTP2.0 一般都跑在 HTTPS 上。
·多路复用，即每一个请求都是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。
·服务器主动响应客户端

# HTTP2协议描述正确的（四个都对）
1. 所有http请求都建立在一个TCP请求上，实现多路复用
2. 可以给请求添加优先级
3. serve push
4. 减少流量传输

# HTTP发展到1.1存在有哪些问题（HTTP2详细改进）：
*·线头阻塞*：TCP每次连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
·虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。
*·头部冗余*，采用文本格式，HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
*·客户端需要主动请求*
  ## 改进http2：
  ### 二进制分帧层
HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。
![二进制分帧层](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\http二进制分层.png)
1.1响应是文本格式，而2.0把响应划分成了两个帧，图中的HEADERS（首部）和DATA（消息负载） 是帧的类型。也就是说一条HTTP响应，划分成了两个帧来传输，并且采用二进制来编码。

  ### 多路复用
上面提到HTTP/1.1的线头阻塞和多个TCP连接的问题，HTTP2的多路复用完美解决。HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。我们来看一下HTTP2具体是怎么实现的：
![多路复用](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\http2多路复用.png)
HTTP2建立一个TCP连接，一个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。 

  ### 头部压缩
头部压缩也是HTTP2的一大亮点。在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如cookie、user-agent等。HTTP2为此采用HPACK压缩格式来压缩首部。头部压缩需要在浏览器和服务器端之间：
    ·维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合
    ·维护一份相同的动态字典，可以动态的添加内容
    ·通过静态Huffman编码对传输的首部字段进行编码
在传输首部字段的时候，例如要传输method:GET,那我们只需要传输静态字典里面method:GET对应的索引值就可以了，一个字节搞定。像user-agent、cookie这种静态字典里面只有首部名称而没有值的首部，第一次传输需要user-agent在静态字典中的索引以及他的值，值会采用静态Huffman编码来减小体积。

  ### 服务器端推送
服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。



# Http和Https区别（高频）（ https与SSL握手）
1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2.`HTTP` 是不安全的，而 HTTPS 是安全的
3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443
4.`在OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密
6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。
·HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。

·HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。

 ## SSL握手
![SSL握手](C:\Users\Lenovo\Desktop\JsVueReact复习\SSL握手.png)

# （高频） UDP和 TDP
## UDP 
  全称是 User Datagram Protocol，用户数据报协议。它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。
  数据报是与分组交换网络关联的传输单元。

UDP 的特点主要有：
    ·UDP 能够支持*容忍数据包丢失*的带宽密集型应用程序
    ·UDP 具有*低延迟*的特点
    ·UDP 能够*发送大量的数据包*
    ·UDP 能够*允许 DNS 查找*，DNS 是建立在 UDP 之上的应用层协议。

## TCP 
全称是 Transmission Control Protocol ，传输控制协议。通过三次握手来建立 TCP 连接。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。
TCP 的主要特点有：
    ·TCP 能够*确保*连接的建立和数据包的发送
    ·TCP 支持错误*重传机制*
    ·TCP 支持*拥塞控制*，能够在网络拥堵的情况下延迟发送
    ·TCP 能够提供*错误校验和*，甄别有害的数据包。

![TCP与UDP的不同](C:\Users\Lenovo\Desktop\JsVueReact复习\tcp与udp的不同.png)
## TCP与UDP的不同
| TCP                                                    | UDP                             |
| ------------------------------------------------------ | --------------------------------|
| 面向连接的协议                                   |  无连接的协议                           |
| 在发送数据前先需要建立连接，然后再发送数据         |  无需建立连接就可以直接发送大量数据       |
| *有流量控制和拥塞控制*                            |  无有流量控制和拥塞控制                 |
| 会按照*特定顺序重新排列数据包*                       |  数据包没有固定顺序，所有数据包都相互独立 |
| 传输的速度比较慢                                   |  传输的速度比较快                         |
| 的头部字节最少有20字节                               |  头部字节只需要8个字节                |
| 是重量级的，发送任何数据前，都要三次握手建立连接。 |  是轻量级的。没有跟踪连接，消息排序等。   |
| 会进行*错误校验*，并进行错误恢复                 |  会错误检查，但会丢弃错误的数据包。     |
| 有发送确认                                         |  没有发送确认                             |
| 是*可靠的*，因为它可以确保将数据传送到路由器。       | 不能保证将数据传送到目标。          |



# （高频）说一下从url输入到返回请求的过程
   ### 1·DNS解析查找
    1.输入url后，先对url进行解析。
    2.走DNS缓存：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。如果缓存了你要访问的URL，就返回 IP 地址。没有就发起一个DNS查询。
    3.DNS查询：查找顺序：本地域名服务器中(没有话) => 根域名服务器 => (TLD)顶级域名服务器 => 权威DNS服务器，直到找到IP地址，然后把它记录在本地，供下次使用。

   ### 2·发起TCP连接
    TCP三次握手，四次挥手
   #### 三次握手
    ·第一次握手：
    客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
    ·第二次握手：
    服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    ·第三次握手：
    客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入  ESTABLISHED状态，完成三次握手。
    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
   ![tcp三次握手](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp三次握手.png)

   #### 四次挥手
   ![tcp四次挥手](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp四次挥手.png)
   ##### 为什么客户端最后还要等待2MSL？
    ·MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
    ·第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
    ·第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

   #### tcp字段
   ![tcp](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp.png)
   
   #### 字段分析：
   · 源端口：源端口和IP地址的作用是标识报文的返回地址。

   · 目的端口：端口指明接收方计算机上的应用程序接口。
  
   · TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。
  
   · 序号：是TCP可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。在TCP传送的流中，  每一个字节都有一个序号。比如一个报文段的序号为300，报文段数据部分共有100字节，则下一个报文段的序  号为400。所以序号确保了TCP传输的有序性。
  
   · 确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号  只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
  
   · 首部长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选  项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表  示的最大值为1111，转化为10进制为15，15*32/8=60，故报头最大长度为60字节。首部长度也叫数据偏移，  是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
  
   · 保留：占6位，保留今后使用，但目前应都位0。
  
   · 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
  
   · 紧急URG：当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据
  
   · 确认ACK：仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。
  
   · 推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对  方的响应，这时候就将PSH=1。
  
   · 复位RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。
  
   · 同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文  中应该使SYN=1，ACK=1。
  
   · 终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。




窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。


校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。


紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。


选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。


数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。


   ### 3·发送HTTP请求
   ！！！HTTP的端口为80/8080，而HTTPS的端口为443
   发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求抱头，请求正文组成。
  ·请求行：
   请求行的格式为：Method  Request-URL  HTTP-Version   CRLF eg: GET index.html  HTTP/1.1 
   常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

   #### HTTP缓存
    ·优点：
        1.减少了冗余的数据传递，节省宽带流量
        2.减少了服务器的负担，大大提高了网站性能
        3.加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。
    ·HTTP属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件
    ·缓存的规则：分为强制缓存和协商缓存（强制缓存的优先级高于协商缓存，若两种皆存在，且强制缓存命中目标，则协商缓存不再验证标识。）
        ·强制缓存
        当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。
        对于强制缓存，服务器响应的header中会用两个字段来表明—— Expires 和 Cache-Control（中的max-age属性）。

        ·协商缓存
        又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据
        对于协商缓存来说，介绍它的两种缓存方案：
            ·Last-Modified（服务器在响应请求时，会告诉浏览器资源的最后修改时间。）
                属性：if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

            ·Etag（服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定））



   ### 4·服务器处理请求并返回HTTP报文
        返回带有html代码
        
   ### 5·浏览器解析渲染页面
   过程：
        ·解析HTML形成DOM树
        ·解析CSS形成CSSOM 树
        ·合并DOM树和CSSOM树形成渲染树
        ·浏览器开始渲染并绘制页面
            这个过程涉及两个比较重要的概念回流和重绘（重绘不一定回流，回流一定会重绘）
            ·回流：当Render Tree中部分或全部元素的尺寸、结构、或某些  属性发生改变时，浏览器重新渲染部分或全部文档的过程。
            ·重绘：当页面中元素样式的改变并不影响它在文档流中的位置时(color、background-color),浏览器会将新样式赋予给元素并重新绘制它。
        ·显示器显示内容
   
   ### 6·断开连接，TCP四次挥手

# （高频）GET和POST区别（高频）
1.GET在浏览器回退不会再次请求，POST会再次提交请求
2.GET请求会被浏览器主动缓存，POST不会，要手动设置
3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
5.GET参数通过URL传递，POST放在Request body中
6.GET参数暴露在地址栏不安全，POST放在报文内部更安全
7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作
8.GET产生一个TCP数据包，POST产生两个TCP数据包

# 理解xss，csrf，ddos攻击原理以及避免方式
XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
XSS避免方式：
  url参数使用encodeURIComponent方法转义
  尽量不是有InnerHtml插入HTML内容
  使用特殊符号、标签转义符。

CSRF避免方式：
  添加验证码
  使用token
    服务端给用户生成一个token，加密后传递给用户
    用户在提交请求时，需要携带这个token
    服务端验证token是否正确

DDoS又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。
DDos避免方式：
  限制单IP请求频率。
  防火墙等防护设置禁止ICMP包等
  检查特权端口的开放



# Cookie、Session、Token、JWT（注意点）
## 使用 cookie 时需要考虑的问题
·因为存储在客户端，容易被客户端篡改，使用前需要验证合法性
·不要存储敏感数据，比如用户密码，账户余额
·使用 httpOnly 在一定程度上提高安全性
·尽量减少 cookie 的体积，能存储的数据量不能超过 4kb
·设置正确的 domain 和 path，减少数据传输
·cookie 无法跨域
·一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
·移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token

## 使用 session 时需要考虑的问题
·将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session
·当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。
当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。
·sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token


## 使用 token 时需要考虑的问题
·如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
·token 完全由应用管理，所以它可以避开同源策略
·token 可以避免 CSRF 攻击(因为不需要 cookie 了)
·移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token

## 使用 JWT 时需要考虑的问题
·因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
·JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
·JWT 不加密的情况下，不能将秘密数据写入 JWT。
·JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
·JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
·JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
·JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
·为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。


# Cookie、Session、Token、JWT（比较）
## 1.Cookie：
·HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
·cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
·cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）

·cookie 重要的属性（maxAge，expires，httpOnly）
·maxAge
cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。
·expires
过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除
·httpOnly
如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全

## 2.Session
·session 是另一种记录服务器和客户端会话状态的机制
·session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中
![session](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\session.png)
·session 认证流程：
用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

## Cookie 和 Session 的区别
·安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
·存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
·有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
·存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。



## Token（令牌）（jwt方案）
·访问资源接口（API）时所需要的资源凭证
简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
·特点：
  1.服务端无状态化、可扩展性好
  2.支持移动端设备
  3.安全
  4.支持跨程序调用

·token 的身份验证流程：
  1.客户端使用用户名跟密码请求登录
  2.服务端收到请求，去验证用户名与密码
  3.验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
  4.客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
  5.客户端每次向服务端请求资源的时候需要带着服务端签发的 token
  6.服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

·每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
token 完全由应用管理，所以它可以避开同源策略

### JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。
JWT 认证流程：
1.用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT
2.客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）
3.当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用
4.Bearer 模式添加 JWT，其内容看起来是下面这样
```js
Authorization: Bearer <token>
```
（
·客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。
·传输方式
  ·可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。
  ·跨域的时候，可以把 JWT 放在 POST 请求的数据体里。
  ·通过 URL 传输
      ```js
        http://www.example.com/user?token=xxx
      ```
）


```js
客户端
1.在login之后，服务端会返回token，将它储存在本地如（localStorage）
2.在axios请求拦截器中携带token
axios.interceptors.request.use((config) => {
    const token = localStorage.getItem('token')
    if (token) {
        config.headers.authorization = token
    }
    ······
})

服务端
vertifyAuth(ctx, next) {
        //1.获取 token
        const authorization = ctx.headers.authorization
        if (!authorization) {
           ···
        }
        const token = authorization.replace("Bearer ", "")
        //2.验证token
        try {
            const result = await ctx.app.jwt.verify(token, ctx.app.config.jwt.secret);
            //将 token 解析出的用户信息保存到ctx中，供下一个中间件使用 
            ctx.user = result
            await next()
        } catch (err) {
           ···解析失败
        }
    }
}
```

## Token 和 Session 的区别
·Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。
·Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。


# 状态码
*·200* OK
表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。
·201 Created
表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。
·202 Accepted
表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。
·204 No Content
表示目前请求成功，但客户端不需要更新其现有页面。
使用惯例是，在 PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果新创建了资源，那么返回 201 Created 。如果页面需要更新以反映更新后的资源，那么需要返回 200 。
*·301* Moved Permanently
永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。
*·302* Found
临时重定向。但是搜索引擎不会对该资源的链接进行更新。
·303 See Other
通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。
*·304* Not Modified
说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD, 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。
如果返回 200，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.
Last-Modified 和 If-Modified-Since

客户端请求一个文件（A）。 服务器返回文件A，并返回 Last-Modified。
客户端收到响应后，缓存文件A 和 Last-Modified。
客户端再次请求文件A 时，发现该文件有 Last-Modified ，那么 header 离包含 If-Modified-Since，这个时间就是缓存文件的 Last-Modified。
服务端收到请求，只需要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200

If-Modified-Since 的主要缺点是只能精确到秒的级别，一旦在一秒内出现多次修改，是无法判断出已修改的状态。所以一般用在对时间不太敏感的静态资源。
ETag 和 If-None-Match

客户端请求一个文件（A）。 服务器返回文件A，并在给A加上一个 ETag。
客户端收到响应后，并将文件连同 ETag 一起缓存。
客户再次请求文件A，会发送 If-None-Match，内容是缓存该文件A的 Etag 值
服务器检查该 ETag，和计算出来的 Etag 匹配，来判断文件是否未被修改。如果未修改就直接返回 304 和一个空的响应体。否则返回 200 和 文件。
当与  If-Modified-Since  一同使用的时候，If-None-Match 优先级更高（假如服务器支持的话）

·307 Temporary Redirect
临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。
·308  Permanent Redirect
永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。
*·400* Bad Request
·表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。
*·401* Unauthorized
说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。
WWW-Authenticate 和 Authorization
WWW-Authenticate 定义了应该用来访问资源的认证方法

·403 Forbidden
指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）
*·404* Not Found
说明服务器端无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理
·404 不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410 (Gone) 而不是 404 。
·405 Method Not Allowed
表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。
·406 Not Acceptable
表示服务器端不支持 Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的。
Accept 和 Content-Type
Accept 用来告知客户端可以处理的内容类型，这种内容类型用 MIME 类型来表示。服务器从中选择一项进行应用，并使用 Content-Type 应答头通知客户端。

·409 Conflict
表示请求与服务器端目标资源的当前状态相冲突。

·410 Gone
说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404。
·413 Payload Too Large
表示请求主体的大小超过了服务器愿意或有能力处理的限度，服务器可能会（may）关闭连接以防止客户端继续发送该请求。
。
·412 Precondition Failed
表示客户端错误，意味着对于目标资源的访问请求被拒绝。

·414  URI Too Long
表示客户端所请求的 URI 超过了服务器允许的范围。
·431 Request Header Fields Too Large
表示由于请求中的首部字段的值过大，服务器拒绝接受客户端的请求。客户端可以在缩减首部字段的体积后再次发送请求。

*·500* Internal Server Error
表示所请求的服务器遇到意外的情况并阻止其执行请求。
举例：代码语法错误；php代码运行内存超了内存限制 memory_limit；nginx config 配置错误；

·501 Not Implemented
表示request header 里的 method 或 Content-* 时不被服务器支持，无法被处理。另，服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。·501 响应默认是可缓存的。

·502 Bad Gateway
表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。

*·503* Service Unavailable
表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。
举例：服务器停机维护时，主动用503响应请求；nginx 设置限速之类的，超过限速，会返回503。
Retry-After
表示用户代理需要等待多长时间之后才能继续发送请求。这个首部主要应用于以下几种场景：

·504 Gateway Timeout
表示网关或者代理的服务器无法在规定的时间内获得想要的响应。
举例：代码执行时间超时，或死循环了。

# 【网络】Socket通信原理
## Socket是什么
Socket是应用层与TCP/IP协议族通信的*中间软件抽象层*，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它*把复杂的TCP/IP协议族隐藏在Socket接口后面*，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

## 网络中进程之间如何通信？
在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用*三元组（ip地址，协议，端口）*就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。

## socket中TCP的三次握手建立连接详解
我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：
  ·客户端向服务器发送一个SYN J
  ·服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1
  ·客户端再想服务器发一个确认ACK K+1

只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？
当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。
总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。

## socket中TCP的四次握手释放连接详解
上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程：
  ·某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；
  ·另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味  着应用进程在相应的连接上再也接收不到额外数据；
  ·一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；
  ·接收到这个FIN的源发送端TCP对它进行确认。
这样每个方向上都有一个FIN和ACK。



# 计算机组成原理
## 总线
总线将计算机的两个或多个功能单元连接到一起并且允许他们相互交换数据。总线还将计算机与外设连接在一起。

