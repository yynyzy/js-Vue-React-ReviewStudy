# 1.node 中的事件循环
浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node中事件循环的实现是依靠的libuv引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。
·宏任务和微任务
node 中也有宏任务和微任务，与浏览器中的事件循环类似，其中，
  macro-task 大概包括：
    ·setTimeout
    ·setInterval
    ·setImmediate
    ·script（整体代码)
    ·I/O 操作等。

  micro-task 大概包括：
    ·process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)
    ·new Promise().then(回调)等。

node事件循环整体理解
先看一张官网的 node 事件循环简化图：

图中的每个框被称为事件循环机制的一个阶段，每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。

node 的事件循环的阶段顺序为：
输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
阶段概述

·定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
·I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
·闲置阶段(idle, prepare)：仅系统内部使用。
·轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
·检查阶段(check)：setImmediate() 回调函数在这里执行
·关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。

# 2.node间进程通信
·管道通信：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了。
·消息队列通信：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制。
·共享内存通信：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式。
·信号量通信：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了。
·socket：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

# 3.node 多进程

# 4.Chrome 多进程架构好处
![Chrome多进程架构](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\Chrome多进程架构.png)
## 打开一个页面基本要使用到的进程配比是这样的：
*1个浏览器进程+1个GPU进程+1个网络进程+多个渲染进程（非同站点tab）+多个插件进程*
几个进程各自作用如下：
*浏览器主进程：*
主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
*GPU进程：*
GPU进程起初是用来实现3D CSS的效果，而一开始chrome浏览器也并没有GPU进程。随之网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器的普遍需求。最后Chrome浏览器在其多进程架构上也引入了GPU进程。
*网络进程：*
主要是负责页面的网络资源加载。
*渲染进程：*
核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
*插件进程：*
主要是负责插件的运行，因插件容易崩溃，所以需要插件进程来隔离，以保证插件进行崩溃不会对浏览器和页面造成影响。
当然页面如果存在iframe的话，iframe也会运行在单独的进程中。

## 为何浏览器要使用多进程架构设计？
为了让浏览器更稳定、流畅和安全。
起初浏览器的所有功能模块都是运行在同一个进程中，暴露了很多问题：
*不稳定性*。插件是不稳定的模块，一旦崩溃，会导致整个浏览器崩溃。渲染引擎模块也是如此，一个标签页崩溃，其他标签页也会崩溃。
*不流畅性*。单进程浏览器中的功能模块运行在同一线程中，同一时刻只能执行一个功能模块。若JavaScript引擎执行了无限循环的脚本，其他功能就没有被执行的机会。浏览器便会卡顿，失去响应。
*不安全性*。页面JavaScript脚本，也可以通过浏览器漏洞获取系统权限，此两种方式均可攻击电脑，引发安全问题。







