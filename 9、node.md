# 1.node 中的事件循环
浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node中事件循环的实现是依靠的libuv引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。
·宏任务和微任务
node 中也有宏任务和微任务，与浏览器中的事件循环类似，其中，
  macro-task 大概包括：
    ·setTimeout
    ·setInterval
    ·setImmediate
    ·script（整体代码)
    ·I/O 操作等。

  micro-task 大概包括：
    ·process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)
    ·new Promise().then(回调)等。


## node 的事件循环的阶段顺序为：
输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...
阶段概述

·*定时器检测阶段(timers)*：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
·*I/O事件回调阶段(I/O callbacks)*：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。
·*闲置阶段(idle, prepare)*：仅系统内部使用。
·*轮询阶段(poll)*：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。
·*检查阶段(check)*：setImmediate() 回调函数在这里执行
·*关闭事件回调阶段(close callback)*：一些关闭的回调函数，如：socket.on('close', ...)。

# 2.node间进程通信
*·管道通信*：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了。
*·消息队列通信*：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制。
*·共享内存通信*：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式。
*·信号量通信*：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了。
*·socket*：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

# 3.node 多进程
js是脚本语言不能直接被识别的，需要浏览器引擎去通过一系列词法分析专程AST树在经过中间一系列优化传成机器码。为了使js在服务端环境运行 我们node引入了v8引擎
Js在执行一段代码时候 首先会在主进程创建一个执行栈 然后创建一个上下文push到执行栈 如果遇到函数 则会创建一个函数的上下文 push到栈内。
当代码存在异步操作的时候 引擎将异步代码移出调用站放入一个事件队列里面 然后继续执行后续程序 eventloop尝试用libuv线程池里面取出一个空闲的线程去执行队列里面的操作 执行完毕获得结果通知主线程 主线程执行相关回调函数 并将线程归还给线程池。

*所以说node是单线程也指的是主线程是单线程的。*
总结一下一个node进程创建了哪些线程：
·Javascript 执行主线程
·watchdog 监控线程用于处理调试信息
·v8 task scheduler 线程用于调度任务优先级，加速延迟敏感任务执行
·4 个 v8 线程 主要用来执行代码调优与 GC 等后台任务；以及用于异步 I / O 的 libuv 线程池。

## 2.Node多进程
我们编程的时候要考虑如何利用多进程多线程来充分利用多核cpu的优势 从而优化我们的性能 接下来介绍node如何创建多进程
![node多进程](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\node多进程.png)
这个例子很简单 首先引入 child_process 包 fork子进程 然后通过ipc通信的方式 调用on以及send方法 与父进程通信 当然 node内部还实现了更快速创建多进程服务的方法

## 3.node多进程模型
操作系统将一切都抽象成文件 包括刚刚提到的套接字 文件描述符相当于对应表的指针。

那如果每个进程都去监听80是不是会解决这个问题呢 但是会发现直接的监听最后只会有一个进程抢占端口成功，其他进程会抛出端口被占用的异常。为了解决这个问题，Node 用了另外一种架构模式
![node多进程（2）](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\node多进程（2）.png)
一开始依然是 master 进程监听 80，当收到用户请求之后，master 并不是直接把这些数据扔给 worker，而是在 80 端口接收到数据后，生成对应的 socket，再把该 socket 对应的文件描述符通过管道传给 worker，一个 socket 意味着服务端和客户端的一个数据通道，也就意味着 master 把跟客户端的数据通道传给了 worker。
在之后 master 停止监听 80port，因为已经把文件描述符给了 worker，之后 worker 直接监听这个套接字即可 那监听多个端口如何做到不报错的呢?
首先：
1.Node 对每个端口监听设置了SO_REUSEADRR,标示可以允许这个端口被多个进程监听
2.用这个的前提是每个监听这个端口的进程，监听的文件描述符要相同（每个子进程收到的文件描述符都是一样的，这个时候就是*所有子进程*监听*相同的 socket 文件描述符*，就可以实现多个进程监听同一个端口的目的了）

*cluster模块为什么可以让多个子进程监听同一个端口呢?*
原因是master进程内部启动了一个TCP服务器，而真正监听端口的只有这个服务器，当来自前端的请求触发服务器的connection事件后，master会将对应的socket具柄发送给子进程  Node 对每个端口监听设置了SO_REUSEADRR,标示可以允许这个端口被多个进程监听 用这个的前提是每个监听这个端口的进程，监听的文件描述符要相同 master 在与 worker 通信的时候，每个子进程收到的文件描述符都是一样的，这个时候就是所有子进程监听相同的 socket 文件描述符，就可以实现多个进程监听同一个端口的目的了

## 4、node进程守护
场景
未捕获异常:当代码抛出了异常没有被捕获到时，进程将会退出
OOM、系统异常而当一个进程出现异常导致 crash 或者 OOM 被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，只能够让当前进程直接退出，Master 立刻 fork 一个新的 Worker。

发生错误 我们监听到之后重新fork一个进程 使其优雅的退出
```js
const cluster = require('cluster');
const os = require('os');

if (cluster.isMaster) {
    for(let i = 0; i < os.cpus().length/2; i++) {

      cluster.fork();
    }   
    cluster.on('exit', () => {
       setTimeout(() => {
           cluster.fork()
       }, 5000)
    })
} else {
    require('./app.js');
    process.on('uncaughtException', (err) => {
      console.error(err);
      process.exit(1)
    })
};
```

*总结*
node对进程异常做的处理:
1.关闭异常 Worker 进程所有的 TCP Server（将已有的连接快速断开，且不再接收新的连接），断开和 Master 的 IPC 通道，不再接受新的用户请求。
2.Master 立刻 fork 一个新的 Worker 进程，保证work数量不变
3.异常 Worker 等待一段时间，处理完已经接受的请求后退出。
多进程带来的问题:
多进程间资源访问冲突
有些工作其实不需要每个 Worker 都去做，如果都做，一来是浪费资源.

# 4.Chrome 多进程架构好处
![Chrome多进程架构](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\Chrome多进程架构.png)
## 打开一个页面基本要使用到的进程配比是这样的：
*1个浏览器进程+1个GPU进程+1个网络进程+多个渲染进程（非同站点tab）+多个插件进程*
几个进程各自作用如下：
*浏览器主进程：*
主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
*GPU进程：*
GPU进程起初是用来实现3D CSS的效果，而一开始chrome浏览器也并没有GPU进程。随之网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器的普遍需求。最后Chrome浏览器在其多进程架构上也引入了GPU进程。
*网络进程：*
主要是负责页面的网络资源加载。
*渲染进程：*
核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
*插件进程：*
主要是负责插件的运行，因插件容易崩溃，所以需要插件进程来隔离，以保证插件进行崩溃不会对浏览器和页面造成影响。
当然页面如果存在iframe的话，iframe也会运行在单独的进程中。

## 为何浏览器要使用多进程架构设计？
为了让浏览器更稳定、流畅和安全。
起初浏览器的所有功能模块都是运行在同一个进程中，暴露了很多问题：
*不稳定性*。插件是不稳定的模块，一旦崩溃，会导致整个浏览器崩溃。渲染引擎模块也是如此，一个标签页崩溃，其他标签页也会崩溃。
*不流畅性*。单进程浏览器中的功能模块运行在同一线程中，同一时刻只能执行一个功能模块。若JavaScript引擎执行了无限循环的脚本，其他功能就没有被执行的机会。浏览器便会卡顿，失去响应。
*不安全性*。页面JavaScript脚本，也可以通过浏览器漏洞获取系统权限，此两种方式均可攻击电脑，引发安全问题。







# 5.MySQL事务、锁和MVCC
## 面试官：你是怎么理解InnoDB引擎中的事务的？
事务可以使「一组操作」要么全部成功，要么全部失败。事务其目的是为了「保证数据最终的一致性」。

*面试官：嗯，那你了解事务的几大特性吗？*
候选者：嗯，就是ACID嘛，分别是*原子性（Atomicity）*、*一致性（Consistency）*、*隔离性（Isolation）*、*持久性（Durability）*。
候选者：
*原子性指的是：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证，因为undo log记载着数据修改前的信息。*
比如我们要 insert 一条数据了，那undo log 会记录的一条对应的 delete 日志。我们要 update 一条记录时，那undo log会记录之前的「旧值」的update记录。
如果执行事务过程中出现异常的情况，那执行「回滚」。InnoDB引擎就是利用undo log记录下的数据，来将数据「恢复」到事务开始之前。

*隔离性指的是：在事务「并发」执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，那么就会产生脏读、重复读、幻读的问题。*
候选者：
于是，事务与事务之间需要存在「一定」的隔离。在InnoDB引擎中，定义了四种隔离级别供我们使用：
分别是：read uncommit(读未提交)、read commit (读已提交)、repeatable read (可重复复读)、serializable (串行)
不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务隔离性越好，但性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节。

*持久性指的就是：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，会将数据持久化在硬盘上。*
候选者：而持久性由redo log 日志来保证，当我们要修改数据时，MySQL是先把这条记录所在的「页」找到，然后把该页加载到内存中，将对应记录进行修改。
为了防止内存修改完了，MySQL就挂掉了（如果内存改完，直接挂掉，那这次的修改相当于就丢失了）。
MySQL引入了redo log，内存写完了，然后会写一份redo log，这份redo log记载着这次在某个页上做了什么修改。
即便MySQL在中途挂了，我们还可以根据redo log来对数据进行恢复。
redo log 是顺序写的，写入速度很快。并且它记录的是物理修改（xxxx页做了xxx修改），文件的体积很小，恢复速度也很快。

*一致性指的：就是一致性可以理解为我们使用事务的「目的」，而「隔离性」「原子性」「持久性」均是为了保障「一致性」的手段，保证一致性需要由应用程序代码来保证*
候选者：比如，如果事务在发生的过程中，出现了异常情况，此时你就得回滚事务，而不是强行提交事务来导致数据不一致。

## 面试官：刚才你也提到了隔离性嘛，然后你说在MySQL中有四种隔离级别，能分别来介绍下吗？
候选者：先来说下MySQL锁相关的知识吧。*在InnoDB引擎下，按锁的粒度分类，可以简单分为行锁和表锁。*
候选者：行锁实际上是作用在索引之上的。当我们的SQL命中了索引，那锁住的就是命中条件内的索引节点（这种就是行锁），如果没有命中索引，那我们锁的就是整个索引树（表锁）。
候选者：简单来说就是：锁住的是整棵树还是某几个节点，完全取决于SQL条件是否有命中到对应的索引节点。
候选者：而行锁又可以简单分为*读锁（共享锁、S锁）*和*写锁（排它锁、X锁）*。
候选者：*读锁是共享的*，多个事务可以同时读取同一个资源，*但不允许其他事务修改*。*写锁是排他的*，写锁会*阻塞其他的写锁和读锁*。

·回到隔离级别上吧
*read uncommit(读未提交)：*读不加锁，修改加写锁，会脏读
*read commit (读已提交)：*隔离级别解决了脏读。在读取的时候生成一个”版本号”，等到其他事务commit了之后，才会读取最新已commit的”版本号”数据。
*repeatable read (可重复复读)：*隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了(commit)，也只会读取当前事务版本的数据。
*serializable (串行)：*它的最高的隔离级别，相当于不允许事务的并发，事务与事务之间执行是串行的，它的效率最低，但同时也是最安全的。

频繁加锁会导致数据库性能低下，引入了MVCC多版本控制来实现读写不阻塞，提高数据库性能
