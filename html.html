<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- <script>

        function observer(target) {
            if (!target && typeof target !== 'object') {
                return
            }
            Object.keys(target).forEach((k) => {
                defineReactive(target, key, target[k])
            })
        }

        function defineReactive(target, key, val) {
            // 递归响应，处理嵌套对象
            observer(val)

            // 创建Dep实例： Dep和key一对一对应
            const dep = new Dep()

            Object.defineProperty(obj, key, {
                get() {
                    //收集依赖
                    Dep.target && dep.addSub(Dep.target)
                    return val
                },
                set(newV) {
                    if (val !== newV) {
                        //传入的新值可能是对象，需要遍历
                        observe(newV)
                        val = newV
                        dep.notify()
                    }
                }
            })
        }

        // Dep: 管理若干watcher实例，它和key一对一关系
        class Dep {
            constructor() {
                this.subs = []
            }
            addSub(sub) {

                this.subs.push(sub)
            }
            notify(val) {
                this.subs.forEach((sub) => {
                    sub.update()
                })
            }
        }

        // 实现update函数可以更新
        class Watcher {
            constructor(vm, key, cb) {
                // this.vm = vm
                // this.key = key
                // this.cb = cb

                // 将当前实例指向Dep.target
                Dep.target = this
                // this.vm[this.key]
                // Dep.target = null
            }

            update() {
                console.log(`${this.key}属性更新了`)
                // this.cb(this.vm.$data[this.key])
            }
        }
        //new Watcher(this, 'test')  //对当前的组件创建一个watcher 用于更新
        //observe(vue.$data)        

    </script> -->
</body>
<script>
    function race(arr) {
        return new Promise((resolve, reject) => {
            if (!Array.isArray(arr)) { return reject(new Error('请输入数组')) }
            for (let i = 0; i < arr.length; i++) {
                Promise.resolve(arr[i]).then((val) => {
                    resolve(val)
                }).catch(err => {
                    reject(err)
                })
            }
        })
    }



    //p1:0.5s后转化为fullfilled状态
    let p1 = new Promise((res, rej) => {
        setTimeout(() => {
            res("p1调用成功")
        }, 500)
    })

    //p2: 直接转化为res状态
    let p2 = new Promise((res, rej) => {
        res("p2调用成功")
    })

    //p3: 1s后转化为rejected状态
    let p3 = new Promise((res, rej) => {
        setTimeout(() => {
            rej("p3失败了...")
        }, 1000)
    })

    //p4: 2s后转化为rejected状态
    let p4 = new Promise((res, rej) => {
        setTimeout(() => {
            rej("p4失败了...")
        }, 2000)
    })

    //传入p1,p2
    Promise.race([p1, p2]).then(res => {
        console.log(res)  //p2调用成功
    })

    //传入p1,p3
    Promise.race([p1, p3]).then(res => {
        console.log(res)  //p1调用成功
    }).catch(rej => {
        console.log(rej)
    })

    //传入p3,p4
    Promise.race([p3, p4]).then(res => {
        console.log(res)
    }).catch(rej => {
        console.log(rej)  //p3失败了...
    })




</script>

</html>