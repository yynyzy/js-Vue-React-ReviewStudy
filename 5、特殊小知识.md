# 1.实现两个值的交换，而不必使用临时变量
使用异或
```
    let a = 3       //0011
    let b = 5       //0101

    a = a ^ b       //0011 ^ 0101 = 0110
    b = b ^ a       //0101 ^ 0110 = 0011   3
    a = a ^ b       //0110 ^ 0011 = 0101   5
    console.log(a); //5
    console.log(b); //3
```

# 2.数组push函数返回的是什么
    const a=[].push(3)  //a  1
    返回的是数组的长度

# slice()和splice()区别
1.slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。

·注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。

2.splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目或数字。（该方法会改变原数组）
```
splice（index,howmany,item1,...itemX）
    ·index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。
    ·howmany参数：必须，要删除的数量，如果为0，则不删除项目。
    ·tem1,...itemX参数：可选，向数组添加的新项目。
```

# 设计和实现一个  LRU (最近最少使用) 缓存机制。
```
class LRU {
        //capacity :  缓存的容量
        constructor(capacity) {
            this.capacity = capacity;
            this.map = new Map()
        }
        /*
        *  get: 你每当获取即使了这个数，就将它从 map中移到最后，即代表最新使用，
        */
        get(key) {
            let val = this.map.get(key);
            if (val === "undefined") return -1;
            this.map.delete(key);
            this.map.set(key, val)
        }
        /*
        *  put: 第一步 如果 map 中已经存在这个数，就将它删除，
        *       第二步 将这个数储存到map中
        *       第三步 capacity为你设置的容量，判断 map 中储存的数量是否超过了容量，如果是则通过*       while循环 this.map.keys().next().value删除开头的值        
        */
        put(key, val) {
            if (this.map.has(key)) {
                this.map.delete(key);
            }
            this.map.set(key, val)
            let keys = this.map.keys()
            while (this.capacity < this.map.size) {
                this.map.delete(keys.next().value)
            }
        }
    }
```