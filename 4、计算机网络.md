# HTTP 1.1
·HTTP 1.1 使用了摘要算法来进行身份验证
·HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据。长连接的连接时长可以通过请求头中的 keep-alive 来设置
·HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制 缓存失效。
·HTTP 1.1 支持断点续传，通过使用请求头中的 Range 来实现。
·HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
·HTTP/1.1管线化可以支持请求并发
缺点：
  ·线头阻塞：TCP每次连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
  ·虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个·TCP连接，建立TCP连接成本很 高，还会存在慢启动的问题。
  ·头部冗余，采用文本格式HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
  ·客户端需要主动请求

# HTTP 2.0
·头部压缩，由于 HTTP 1.1 经常会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导 致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
·二进制格式，采用二进制格式而非文本模式，提升了解析效率，数据更紧凑，减少错误
·强化安全， HTTP2.0 一般都跑在 HTTPS 上。
·多路复用，即每一个请求都是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。
·服务器主动响应客户端

# HTTP2协议描述正确的（四个都对）
1. 所有http请求都建立在一个TCP请求上，实现多路复用
2. 可以给请求添加优先级
3. serve push
4. 减少流量传输

# HTTP发展到1.1存在有哪些问题（HTTP2详细改进）：
·线头阻塞：TCP每次连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
·虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。
·头部冗余，采用文本格式，HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
·客户端需要主动请求
  ## 改进：
  ### 二进制分帧层
HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。
![二进制分帧层](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\http二进制分层.png)
1.1响应是文本格式，而2.0把响应划分成了两个帧，图中的HEADERS（首部）和DATA（消息负载） 是帧的类型。也就是说一条HTTP响应，划分成了两个帧来传输，并且采用二进制来编码。

  ### 多路复用
上面提到HTTP/1.1的线头阻塞和多个TCP连接的问题，HTTP2的多路复用完美解决。HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。我们来看一下HTTP2具体是怎么实现的：
![多路复用](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\http2多路复用.png)
HTTP2建立一个TCP连接，一个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应。这使得所有的请求或响应都无法阻塞。 

  ### 头部压缩
头部压缩也是HTTP2的一大亮点。在1.X版本中，首部用文本格式传输，通常会给每个传输增加500-800字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如cookie、user-agent等。HTTP2为此采用HPACK压缩格式来压缩首部。头部压缩需要在浏览器和服务器端之间：
    ·维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合
    ·维护一份相同的动态字典，可以动态的添加内容
    ·通过静态Huffman编码对传输的首部字段进行编码
在传输首部字段的时候，例如要传输method:GET,那我们只需要传输静态字典里面method:GET对应的索引值就可以了，一个字节搞定。像user-agent、cookie这种静态字典里面只有首部名称而没有值的首部，第一次传输需要user-agent在静态字典中的索引以及他的值，值会采用静态Huffman编码来减小体积。

  ### 服务器端推送
服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。



# Http和Https区别（高频）（ https与SSL握手）
1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2.`HTTP` 是不安全的，而 HTTPS 是安全的
3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443
4.`在OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密
6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。
·HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。

·HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。

 ## SSL握手
![SSL握手](C:\Users\Lenovo\Desktop\JsVueReact复习\SSL握手.png)

# （高频） UDP和 TDP
## UDP 
  全称是 User Datagram Protocol，用户数据报协议。它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。
数据报是与分组交换网络关联的传输单元。

UDP 的特点主要有：
    ·UDP 能够支持容忍数据包丢失的带宽密集型应用程序
    ·UDP 具有低延迟的特点
    ·UDP 能够发送大量的数据包
    ·UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。

## TCP 
全称是 Transmission Control Protocol ，传输控制协议。通过三次握手来建立 TCP 连接。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。
TCP 的主要特点有：
    ·TCP 能够确保连接的建立和数据包的发送
    ·TCP 支持错误重传机制
    ·TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送
    ·TCP 能够提供错误校验和，甄别有害的数据包。

![TCP与UDP的不同](C:\Users\Lenovo\Desktop\JsVueReact复习\tcp与udp的不同.png)
  ## TCP与UDP的不同
| TCP                                                    | UDP                                          |
| ------------------------------------------------------ | -------------------------------------------- |
| 面向连接的协议                                   |  无连接的协议                           |
| 在发送数据前先需要建立连接，然后再发送数据         |  无需建立连接就可以直接发送大量数据       |
| 有流量控制和拥塞控制                              |  无有流量控制和拥塞控制                 |
| 会按照特定顺序重新排列数据包                       |  数据包没有固定顺序，所有数据包都相互独立 |
| 传输的速度比较慢                                   |  传输的速度比较快                             |
| 的头部字节最少有20字节                               |  头部字节只需要8个字节                |
| 是重量级的，发送任何数据前，都要三次握手建立连接。 |  是轻量级的。没有跟踪连接，消息排序等。   |
| 会进行错误校验，并进行错误恢复                 |  会错误检查，但会丢弃错误的数据包。     |
| 有发送确认                                         |  没有发送确认                             |
| 是可靠的，因为它可以确保将数据传送到路由器。       | 不能保证将数据传送到目标。          |



# （高频）说一下从url输入到返回请求的过程
   ### 1·DNS解析查找
    1.输入url后，先对url进行解析。
    2.走DNS缓存：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。如果缓存了你要访问的URL，就返回 IP 地址。没有就发起一个DNS查询。
    3.DNS查询：查找顺序：本地域名服务器中(没有话) => 根域名服务器 => (TLD)顶级域名服务器 => 权威DNS服务器，直到找到IP地址，然后把它记录在本地，供下次使用。

   ### 2·发起TCP连接
    TCP三次握手，四次挥手
   #### 三次握手
    ·第一次握手：
    客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
    ·第二次握手：
    服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    ·第三次握手：
    客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入  ESTABLISHED状态，完成三次握手。
    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
   ![tcp三次握手](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp三次握手.png)

   #### 四次挥手
   ![tcp四次挥手](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp四次挥手.png)
   ##### 为什么客户端最后还要等待2MSL？
    ·MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
    ·第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
    ·第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

   #### tcp字段
   ![tcp](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\tcp.png)
   #### 字段分析：
   · 源端口：源端口和IP地址的作用是标识报文的返回地址。

   · 目的端口：端口指明接收方计算机上的应用程序接口。
  
   · TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。
  
   · 序号：是TCP可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。在TCP传送的流中，  每一个字节都有一个序号。比如一个报文段的序号为300，报文段数据部分共有100字节，则下一个报文段的序  号为400。所以序号确保了TCP传输的有序性。
  
   · 确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号  只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
  
   · 首部长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选  项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表  示的最大值为1111，转化为10进制为15，15*32/8=60，故报头最大长度为60字节。首部长度也叫数据偏移，  是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
  
   · 保留：占6位，保留今后使用，但目前应都位0。
  
   · 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
  
   · 紧急URG：当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据
  
   · 确认ACK：仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。
  
   · 推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对  方的响应，这时候就将PSH=1。
  
   · 复位RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。
  
   · 同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文  中应该使SYN=1，ACK=1。
  
   · 终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。




窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。


校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。


紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。


选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。


数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。


   ### 3·发送HTTP请求
   ！！！HTTP的端口为80/8080，而HTTPS的端口为443
   发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求抱头，请求正文组成。
  ·请求行：
   请求行的格式为：Method  Request-URL  HTTP-Version   CRLF eg: GET index.html  HTTP/1.1 
   常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

   #### HTTP缓存
    ·优点：
        1.减少了冗余的数据传递，节省宽带流量
        2.减少了服务器的负担，大大提高了网站性能
        3.加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。
    ·HTTP属于客户端缓存，我们常认为浏览器有一个缓存数据库，用来保存一些静态文件
    ·缓存的规则：分为强制缓存和协商缓存（强制缓存的优先级高于协商缓存，若两种皆存在，且强制缓存命中目标，则协商缓存不再验证标识。）
        ·强制缓存
        当缓存数据库中有客户端需要的数据，客户端直接将数据从其中拿出来使用（如果数据未失效），当缓存服务器没有需要的数据时，客户端才会向服务端请求。
        对于强制缓存，服务器响应的header中会用两个字段来表明—— Expires 和 Cache-Control（中的max-age属性）。

        ·协商缓存
        又称对比缓存。客户端会先从缓存数据库拿到一个缓存的标识，然后向服务端验证标识是否失效，如果没有失效服务端会返回304，这样客户端可以直接去缓存数据库拿出数据，如果失效，服务端会返回新的数据
        对于协商缓存来说，介绍它的两种缓存方案：
            ·Last-Modified（服务器在响应请求时，会告诉浏览器资源的最后修改时间。）
                属性：if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

            ·Etag（服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定））



   ### 4·服务器处理请求并返回HTTP报文
        返回带有html代码
        
   ### 5·浏览器解析渲染页面
   过程：
        ·解析HTML形成DOM树
        ·解析CSS形成CSSOM 树
        ·合并DOM树和CSSOM树形成渲染树
        ·浏览器开始渲染并绘制页面
            这个过程涉及两个比较重要的概念回流和重绘（重绘不一定回流，回流一定会重绘）
            ·回流：当Render Tree中部分或全部元素的尺寸、结构、或某些  属性发生改变时，浏览器重新渲染部分或全部文档的过程。
            ·重绘：当页面中元素样式的改变并不影响它在文档流中的位置时(color、background-color),浏览器会将新样式赋予给元素并重新绘制它。
        ·显示器显示内容
   
   ### 6·断开连接，TCP四次挥手

# （高频）GET和POST区别（高频）
1.GET在浏览器回退不会再次请求，POST会再次提交请求
2.GET请求会被浏览器主动缓存，POST不会，要手动设置
3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
5.GET参数通过URL传递，POST放在Request body中
6.GET参数暴露在地址栏不安全，POST放在报文内部更安全
7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作
8.GET产生一个TCP数据包，POST产生两个TCP数据包

# 理解xss，csrf，ddos攻击原理以及避免方式
XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
XSS避免方式：
  url参数使用encodeURIComponent方法转义
  尽量不是有InnerHtml插入HTML内容
  使用特殊符号、标签转义符。

CSRF避免方式：
  添加验证码
  使用token
    服务端给用户生成一个token，加密后传递给用户
    用户在提交请求时，需要携带这个token
    服务端验证token是否正确

DDoS又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。
DDos避免方式：
  限制单IP请求频率。
  防火墙等防护设置禁止ICMP包等
  检查特权端口的开放
