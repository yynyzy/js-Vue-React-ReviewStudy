# 1.实现两个值的交换，而不必使用临时变量
使用异或
```
    let a = 3       //0011
    let b = 5       //0101

    a = a ^ b       //0011 ^ 0101 = 0110   6
    b = b ^ a       //0101 ^ 0110 = 0011   3
    a = a ^ b       //0110 ^ 0011 = 0101   5
    console.log(a); //5
    console.log(b); //3
```

# 2.数组push函数返回的是什么
    const a=[].push(3)  //a  1
    返回的是数组的长度

# 3.slice()和splice()区别
1.slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。

·注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。

2.splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目或数字。（该方法会改变原数组）
```
splice（index,howmany,item1,...itemX）
    ·index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。
    ·howmany参数：必须，要删除的数量，如果为0，则不删除项目。
    ·tem1,...itemX参数：可选，向数组添加的新项目。
```

# 4.设计和实现一个  LRU (最近最少使用) 缓存机制。
```js
class LRU {
        //capacity :  缓存的容量
        constructor(capacity) {
            this.capacity = capacity;
            this.map = new Map()
        }
        /*
        *  get: 你每当获取即使了这个数，就将它从 map中移到最后，即代表最新使用，
        */
        get(key) {
            let val = this.map.get(key);
            if (val === "undefined") return -1;
            this.map.delete(key);
            this.map.set(key, val)
        }
        /*
        *  put: 第一步 如果 map 中已经存在这个数，就将它删除，
        *       第二步 将这个数储存到map中
        *       第三步 capacity为你设置的容量，判断 map 中储存的数量是否超过了容量，如果是则通过*       while循环 this.map.keys().next().value删除开头的值        
        */
        put(key, val) {
            if (this.map.has(key)) {
                this.map.delete(key);
            }
            this.map.set(key, val)
            let keys = this.map.keys()
            while (this.capacity < this.map.size) {
                this.map.delete(keys.next().value)
            }
        }
    }
```

# 5.获取全局对象
web:window.,this.,frames.
node:global
worker:self.
通用：globalThis

# 6. try catch 输出什么？
```js
    (() => {
            let x, y;
            try {
                throw new Error();
            } catch (x) {
                (x = 1), (y = 2);       //catch(x) 所以 第一个console在作用域中（x=1）为 1，第二个 y=2 是全局赋值
                console.log(x);
            }
            console.log(x);
            console.log(y);
        })();
```
输出：1 undefined 2

# 7. 这题考察的是对象的键名的转换。
对象的键名只能是字符串和 Symbol 类型。
其他类型的键名会被转换成字符串类型。
对象转字符串默认会调用 toString 方法。
```JS
// example 1
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]);
// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉, 输出 c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]);      // 输出 b

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';       
a[c]='c';      
console.log(a[b]); 
// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。  
// 输出 c
```

# 8. 比较相等性
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}
checkAge({ age: 18 });  //Hmm.. You don't have an age I guess
```
在比较相等性，原始类型通过它们的值进行比较，而*对象通过它们的引用进行比较*。JavaScript检查对象是否具有对内存中相同位置的引用。
我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。

# 9.下面代码中什么时候会输出1？
```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
     console.log(1);
}
```
```js
//因为==会进行隐式类型转换 所以我们重写toString方法就可以了
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
```

# 10.输出什么？小心作用域
```js
  let f = true
    if (f == true) {
        var a = 10
    }
    function fn() {
        var b = 20
        c = 30
    }
    fn()
    console.log(a);  //10
    console.log(b);  //Uncaught ReferenceError: b is not defined //因为function 是有作用域的，所以b在全局中找不到
    console.log(c);) //30
```


# 11.this指向
```js
 function test1() {
        var name = 'test1'
        function test2() {
            var name = 'test2'
            function test3() {
                var name = 'test3'
                console.log(this.name);
            }
            test3()
        }
        test2()
    }
    test1() //undefined 指向 window
```

# 12.隐式转化 
  ```js
    var a = {}
    var b = {
        key: 'a'
    }
    var c = {
        key: 'c'
    }
    a[b] = '123'
    a[c] = '456'
    console.log(a[b]) //456

    因为 var a = {} ==>a{
                        { key: 'a'}:'123'
                        { key: 'c'}:'456'
                    }
  ```
    对象的键会自动调用 toString方法 ==》 [Object Object]

# 13.上传文件的相关方法 
    由于原生的input 上传文件样式太丑，所以都是隐藏input ，同时自己添加一个按钮上传文件
    ```js
    input.style.display = 'none'
    //设置自己的上传元素点击事件，点击时触发上传
    mydom.addEventListener('click',()=>{
        input.click()
    })
    //监听 input 的 change 事件来对上传的文件进行操控
    ```
  ## 1.普通 前后都使用 formdata 格式进行上传
    ```js
    let formdata = new FormData()
    formdata.append('file',file) //添加key-value
    formdata.append('fileName',fileName) //添加key-value
    ```
    // 最后把 formdata 上传

  ## 2.使用 base64 上传（可以实现图片预览）
    ```js
    1.先读取文件成 base64格式
    let fileReader = new FileReader()
    fileReader.readAsDataURL()
    fileReader.onload=ev=>{
       base64 = ev.target.result 
    }
    2.通过 encodeURIComponent 对base64 进行编码，防止传输过程中出现乱码
    file: encodeURIComponent(base64)
    3.axios 发送请求时 设置 headers 为 application/x-www-form-urlencoded(后端也需要对接口做配合)
    ```
  
  ## 3.将文件读取成二进制数据并使用 MD5 加密
    ```js
    //需要下载 SparkMD5 库

    let fileReader = new FileReader();
    fileReader.readAsArrayBuffer(file)
    fileReader.onload=(ev) => {
        let buffer = ev.target.result
        let spark = new SparkMD5.ArrayBuffer()
        let HASH = spark.append(buffer)
        //取文件后缀
        let suffix =/\.([a-zA-Z0-9]+)$/.exec(file.name)[1]
        resolve({
            buffer,
            HASH,
            suffix,
            //将MD5加密后的文件名重新组合成新的文件名，防止文件传到服务端后会出现重名的导致上传失败
            filename:`${HASH}.${suffix}`
        })
    }
   
    
    ```

  ## 3.多文件上传可以给 input 标签添加 muplite 表示多文件，accept="image/gif, image/jpeg" 属性表示允许上传以什么格式的文件

  ## 4.拖拽上传可以使用 dragenter（拖拽进入） ， dragleave（拖拽离开），dragover(拖拽移动),drop（松开拖拽）。
给要拖拽上传的区域添加一个监听事件(addEventListener)：
    监听 dragover时 ev.preventDefault 取消默认事件。
    监听 drop事件时，ev.preventDefault 取消默认事件，并且 
    ```js
    let file = ev.dataTransfer.files[0]
    ```
    获取拖拽上传的文件




# 14.~~运算符
简单一点就是将一些变量转化为Number（数字）类型的；
·数字类型的字符串可以转化为纯数字
```js
var a='123'
console.log(~~a); //输出123

·字符串中带了其他字母，符号，或者其他除数字外的东西，一律输出 Number类型的0
var a='asd'

console.log(~~a); //输出0

·任何boolen类型的，如果为TRUE则输出1，FALSE输出0；
var a=1==1;
console.log(~~a);//输出1

·特殊类型，转化为Boolean是true的输出1，转化为boolean是false的输出0；
var a=undefined;
console.log(~~a);//输出0
var b=！undefined;
console.log(~~b);//输出1
```

# 15.link标签引入css会阻塞dom渲染嘛
<link>标签不会阻塞DOM的解析；
<link>标签会阻塞DOM的渲染；
<link>标签同时还会阻塞其之后的<script>标签的执行。

# 16.前端关于单点登录的知识
## 什么是单点登录
单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。

![单点登录](C:\Users\Lenovo\Desktop\JsVueReact复习\单点登录.png)
·用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
·sso认证中心发现用户未登录，将用户引导至登录页面
·用户输入用户名密码提交登录申请
·sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
·sso认证中心带着令牌跳转会最初的请求地址（系统1）
·系统1拿到令牌，去sso认证中心校验令牌是否有效
·sso认证中心校验令牌，返回有效，注册系统1
·系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
·用户访问系统2的受保护资源
·系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
·sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
·系统2拿到令牌，去sso认证中心校验令牌是否有效
·sso认证中心校验令牌，返回有效，注册系统2
·系统2使用该令牌创建与用户的局部会话，返回受保护资源

## 2.注销
sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。
·用户向系统1发起注销请求
·系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求
·sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址
·sso认证中心向所有注册系统发起注销请求
·各注册系统接收sso认证中心的注销请求，销毁局部会话
·sso认证中心引导用户至登录页面


# 17.从以下选项中找出正确的打印值
```js
const one = (false || {} || null)
const two = (null || false || "")
const three = ([] || 0 || true)
console.log(one,two,three);

A. false null [ ]
B. null "" true
C. { } "" [ ]
D. null null true
```

解析：答案；C
```js
const one = (false || {} || null)   // - 任何一个对象转换为布尔值都是真值 {}
const two = (null || false || "")  // - null、undefined、""转换为布尔值都是false，所以值为最后一个  ""
const three = ([] || 0 || true)  // -数组也是对象， []转换为布尔值为真值  []
console.log(one,two,three);  // - {}, "", [] 
```

# 18.有关原型链的两道题目
```js
var A = function() {};
A.prototype.n = 1;
var b = new A();
A.prototype = {
  n: 2,
  m: 3
}
var c = new A();

console.log(b.n);
console.log(b.m);

console.log(c.n);
console.log(c.m);

题目 1 答案：
b.n -> 1
b.m -> undefined;

c.n -> 2;
c.m -> 3;
```

```js
var F = function() {};

Object.prototype.a = function() {
  console.log('a');
};

Function.prototype.b = function() {
  console.log('b');
}

var f = new F();

f.a();
f.b();

F.a();
F.b();

题目 2 答案：
f.a() -> a
f.b() -> f.b is not a function

F.a() -> a
F.b() -> b
```

# 19.js 获取两个数组的交集，并集，补集，差集
```js
const arr1 = [1,2,3,4,5],
      arr2 = [5,6,7,8,9],


// 交集
let intersection =  (a, b) => {
  const s = new Set(b);
  return [...new Set(a)].filter(x => s.has(x));
};

// 并集
let union = Array.from(new Set([...arr1, ...arr2]))

// 补集 两个数组各自没有的集合
let complement = [...arr1.filter(item => ![...new Set(arr2)].has(item)), ...arr2.filter(item => ![...new Set(arr1)].has(item))]

// 差集 数组arr1相对于arr2所没有的
let diff = arr1.filter(item => !_arr2Set.has(item))
```


# 20.git命令系列 --> git stash
*（1）git stash save "save message" :* 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别
*（2）git stash list ：*查看stash了哪些存储
*（3）git stash show ：*显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} 从0开始
*（4）git stash show -p :* 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p
*（5）git stash apply :*应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1}
*（6）git stash pop ：*命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}
*（7）git stash drop stash@{num} ：*丢弃stash@{num}存储，从列表中删除这个存储
*（8）git stash clear ：*删除所有缓存的stash

# 21.Git Fetch和Git Pull命令的特点

*Git Fetch：*
Git fetch 命令在本地仓库工作，它只从远程仓库获取数据，以查看开发人员所做的所有修改或新提交 的内容。
这样它就可以更新开发人员的工作。
但是，它并不复制工作，而是允许开发者查看他承认的工作。

*Git Pull：*
Git Pull 命令在本地仓库工作，它从远程服务器上获取并合并变化到你的工作目录。
这样它就可以编辑或更新工作了。
它制作了一份工作的副本，允许开发者为工作做出更好的贡献。

# 22.js 实现 下拉刷新
页面的滚动区域本来是用的插件vue-scroller，但是由于在一些低端安卓机中页面略有卡动，可能是GPU不给力造成的，这里尝试用原生的overflow: auto; 来测试一下滚动效果，发现效果不错，但是在ios设备中就发现了了滚动没有惯性很死板的体验，这里可以在滚动容器中写一行css属性-webkit-overflow-scrolling: touch;，这样就有原生的滚动体验啦，接下来就差一个下拉刷新的效果了，没有找到现成的轮子，这里就自己开撸

如何实现
当容器的scrollTop为0的时候，使用transform: translateY来模拟
检测下拉的高度当达到某一固定值的时候，释放手指，调用回调函数实现下拉刷新
着手实现
既然是下拉我们肯定需要监听touchstart、touchmove、touchend三个dom事件

*touchstart*
```js
el.addEventListener('touchstart', e => {
    if (el.scrollTop !== 0) {
        return
    }
    beginPagY = e.touches[0].pageY
    e.preventDefault()
})
用于记录手指点按屏幕时候的位置，为了后续translateY的值计算做准备

touchstartmove
el.addEventListener('touchmove', e => {
    if (el.scrollTop !== 0) {
        return
    }
    const pageY = e.touches[0].pageY
    const distance = currentPos = pageY - beginPagY
    if (distance < 0 || distance > maxTranslateY) {
        // 上拉的和超过最大限定高度时候不做任何处理
        return;
    }
    if (distance > 60) {
        iconEl.classList.add('active')
    } else {
        iconEl.classList.remove('active')
    }
    e.preventDefault()
    el.style.transform = `translateY(${distance}px)`
})
```
touchmove主要是根据手指下拉的距离不断的修改container的translate的值来达到效果, 同时记录当前下拉的distance，用于松手是判断是否触发下拉刷新的效果； 同时在模拟下拉效果的时候要阻止系统默认事件e.preventDefault()

*touchend*
```js
let clear = () => {
    this.isShowLoading = false
    el.style.transform = `translateY(0)`
    setTimeout(() => {
        el.style.transition = ``
    }, 200)
}
el.addEventListener('touchend', () => {
    el.style.transition = `.2s`
    if (currentPos >= 60) {
        this.isShowLoading = true
        el.style.transform = `translateY(30px)`
        callback && callback(() => {
            clear()
        })
        return
    }
    clear()
})
```
touchend 主要是用来松手时是否执行下拉刷新的效果， 当currentPos达到预先设定的值的时候就触发回调函数，这里设置transition来增加动画效果

# 100.**10个常用的JS工具库**，80%的项目都在用！

## **Day.js**
一个极简的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持一样, 但体积仅有2KB。
```js
npm install dayjs
```
基本用法
```js
import dayjs from 'dayjs'

dayjs().format('YYYY-MM-DD HH:mm') // => 2022-01-03 15:06
dayjs('2022-1-3 15:06').toDate() // => Mon Jan 03 2022 15:06:00 GMT+0800 (中国标准时间)
```

## **qs**
一个轻量的 url 参数转换的 JavaScript 库
```js
npm install qs
```
基本用法
```js
import qs from 'qs'

qs.parse('user=tom&age=22') // => { user: "tom", age: "22" }
qs.stringify({ user: "tom", age: "22" }) // => user=tom&age=22
```

## **js-cookie**
一个简单的、轻量的处理 cookies 的 js API
```js
npm install js-cookie
```
基本用法
```js
import Cookies from 'js-cookie'

Cookies.set('name', 'value', { expires: 7 }) // 有效期7天
Cookies.get('name') // => 'value'
```

## **flv.js**
bilibili 开源的 html5 flash 视频播放器，使浏览器在不借助 flash 插件的情况下可以播放 flv，目前主流的直播、点播解决方案。
```
npm install flv.js
```
基本用法
```js
<video autoplay controls width="100%" height="500" id="myVideo"></video>

import flvjs from 'flv.js'

// 页面渲染完成后执行
if (flvjs.isSupported()) {
  var myVideo = document.getElementById('myVideo')
  var flvPlayer = flvjs.createPlayer({
    type: 'flv',
    url: 'http://localhost:8080/test.flv' // 视频 url 地址
  })
  flvPlayer.attachMediaElement(myVideo)
  flvPlayer.load()
  flvPlayer.play()
}
```

## **vConsole**
一个轻量、可拓展、针对手机网页的前端开发者调试面板。如果你还苦于在手机上如何调试代码，用它就对了。
```js
npm install vconsole
```
基本用法
```js
import VConsole from 'vconsole'

const vConsole = new VConsole()
console.log('Hello world')
```

## **Animate.css**
一个跨浏览器的 css3 动画库，内置了很多典型的 css3 动画，兼容性好，使用方便。
```js
npm install animate.css
```
基本用法
```js
<h1 class="animate__animated animate__bounce">An animated element</h1>

import 'animate.css'
```

## **animejs**
一款功能强大的 Javascript 动画库。可以与CSS3属性、SVG、DOM元素、JS对象一起工作，制作出各种高性能、平滑过渡的动画效果。
```js
npm install animejs
```
基本用法
```js
<div class="ball" style="width: 50px; height: 50px; background: blue"></div>

import anime from 'animejs/lib/anime.es.js'

// 页面渲染完成之后执行
anime({
  targets: '.ball',
  translateX: 250,
  rotate: '1turn',
  backgroundColor: '#F00',
  duration: 800
})
```

## **lodash.js**
一个一致性、模块化、高性能的 JavaScript 实用工具库
```js
npm install lodash
```
基本用法
```js
import _ from 'lodash'

_.max([4, 2, 8, 6]) // 返回数组中的最大值 => 8
_.intersection([1, 2, 3], [2, 3, 4]) // 返回多个数组的交集 => [2, 3]
```

## **mescroll.js**
一款精致的、在H5端运行的下拉刷新和上拉加载插件，主要用于列表分页、刷新等场景。
```js
npm install mescroll.js
```
基本用法（vue组件）
```vue
<template>
  <div>
    <mescroll-vue
      ref="mescroll"
      :down="mescrollDown"
      :up="mescrollUp"
      @init="mescrollInit"
    >
      <!--内容...-->
    </mescroll-vue>
  </div>
</template>

<script>
import MescrollVue from 'mescroll.js/mescroll.vue'

export default {
  components: {
    MescrollVue
  },
  data() {
    return {
      mescroll: null, // mescroll实例对象
      mescrollDown: {}, //下拉刷新的配置
      mescrollUp: {
        // 上拉加载的配置
        callback: this.upCallback
      },
      dataList: [] // 列表数据
    }
  },
  methods: {
    // 初始化的回调,可获取到mescroll对象
    mescrollInit(mescroll) {
      this.mescroll = mescroll
    },
    // 上拉回调 page = {num:1, size:10}; num:当前页 ,默认从1开始; size:每页数据条数,默认10
    upCallback(page, mescroll) {
      // 发送请求
      axios
        .get('xxxxxx', {
          params: {
            num: page.num, // 当前页码
            size: page.size // 每页长度
          }
        })
        .then(response => {
          // 请求的列表数据
          let arr = response.data
          // 如果是第一页需手动置空列表
          if (page.num === 1) this.dataList = []
          // 把请求到的数据添加到列表
          this.dataList = this.dataList.concat(arr)
          // 数据渲染成功后,隐藏下拉刷新的状态
          this.$nextTick(() => {
            mescroll.endSuccess(arr.length)
          })
        })
        .catch(e => {
          // 请求失败的回调,隐藏下拉刷新和上拉加载的状态;
          mescroll.endErr()
        })
    }
  }
}
</script>

<style scoped>
.mescroll {
  position: fixed;
  top: 44px;
  bottom: 0;
  height: auto;
}
</style>  
```


## **Chart.js**
一套基于 HTML5 的简单、干净并且有吸引力的 JavaScript 图表库
```js
npm install chart.js
```
基本用法
```js
<canvas id="myChart" width="400" height="400"></canvas>

import Chart from 'chart.js/auto'

// 页面渲染完成后执行
const ctx = document.getElementById('myChart')
const myChart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],
    datasets: [
      {
        label: '# of Votes',
        data: [12, 19, 3, 5, 2, 3],
        backgroundColor: [
          'rgba(255, 99, 132, 0.2)',
          'rgba(54, 162, 235, 0.2)',
          'rgba(255, 206, 86, 0.2)',
          'rgba(75, 192, 192, 0.2)',
          'rgba(153, 102, 255, 0.2)',
          'rgba(255, 159, 64, 0.2)'
        ],
        borderColor: [
          'rgba(255, 99, 132, 1)',
          'rgba(54, 162, 235, 1)',
          'rgba(255, 206, 86, 1)',
          'rgba(75, 192, 192, 1)',
          'rgba(153, 102, 255, 1)',
          'rgba(255, 159, 64, 1)'
        ],
        borderWidth: 1
      }
    ]
  },
  options: {
    scales: {
      y: {
        beginAtZero: true
      }
    }
  }
})
```