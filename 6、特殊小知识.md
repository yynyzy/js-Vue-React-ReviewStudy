# 1.实现两个值的交换，而不必使用临时变量
使用异或
```
    let a = 3       //0011
    let b = 5       //0101

    a = a ^ b       //0011 ^ 0101 = 0110   6
    b = b ^ a       //0101 ^ 0110 = 0011   3
    a = a ^ b       //0110 ^ 0011 = 0101   5
    console.log(a); //5
    console.log(b); //3
```

# 2.数组push函数返回的是什么
    const a=[].push(3)  //a  1
    返回的是数组的长度

# 3.slice()和splice()区别
1.slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。

·注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。

2.splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目或数字。（该方法会改变原数组）
```
splice（index,howmany,item1,...itemX）
    ·index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。
    ·howmany参数：必须，要删除的数量，如果为0，则不删除项目。
    ·tem1,...itemX参数：可选，向数组添加的新项目。
```

# 4.设计和实现一个  LRU (最近最少使用) 缓存机制。
```
class LRU {
        //capacity :  缓存的容量
        constructor(capacity) {
            this.capacity = capacity;
            this.map = new Map()
        }
        /*
        *  get: 你每当获取即使了这个数，就将它从 map中移到最后，即代表最新使用，
        */
        get(key) {
            let val = this.map.get(key);
            if (val === "undefined") return -1;
            this.map.delete(key);
            this.map.set(key, val)
        }
        /*
        *  put: 第一步 如果 map 中已经存在这个数，就将它删除，
        *       第二步 将这个数储存到map中
        *       第三步 capacity为你设置的容量，判断 map 中储存的数量是否超过了容量，如果是则通过*       while循环 this.map.keys().next().value删除开头的值        
        */
        put(key, val) {
            if (this.map.has(key)) {
                this.map.delete(key);
            }
            this.map.set(key, val)
            let keys = this.map.keys()
            while (this.capacity < this.map.size) {
                this.map.delete(keys.next().value)
            }
        }
    }
```

# 5.获取全局对象
web:window.,this.,frames.
node:global
worker:self.
通用：globalThis

# 6. try catch 输出什么？
```
    (() => {
            let x, y;
            try {
                throw new Error();
            } catch (x) {
                (x = 1), (y = 2);
                console.log(x);
            }
            console.log(x);
            console.log(y);
        })();
```
输出：1 undefined 2

# 7. 这题考察的是对象的键名的转换。
对象的键名只能是字符串和 Symbol 类型。
其他类型的键名会被转换成字符串类型。
对象转字符串默认会调用 toString 方法。
```
// example 1
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]);
// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉, 输出 c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]);      // 输出 b

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';       
a[c]='c';      
console.log(a[b]); 
// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。  
// 输出 c
```

# 8. 比较相等性
```
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}
checkAge({ age: 18 });  //Hmm.. You don't have an age I guess
```
在比较相等性，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。JavaScript检查对象是否具有对内存中相同位置的引用。
我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。

# 9.下面代码中什么时候会输出1？
```
var a = ?;
if(a == 1 && a == 2 && a == 3){
     conso.log(1);
}
```
```
//因为==会进行隐式类型转换 所以我们重写toString方法就可以了
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
```

# 10.输出什么？小心作用域
  let f = true
    if (f == true) {
        var a = 10
    }
    function fn() {
        var b = 20
        c = 30
    }
    fn()
    console.log(a);  //10
    console.log(b);  //Uncaught ReferenceError: b is not defined //因为function 是有作用域的，所以b在全局中找不到
    console.log(c);)


# 11.this指向
```
 function test1() {
        var name = 'test1'
        function test2() {
            var name = 'test2'
            function test3() {
                var name = 'test3'
                console.log(this.name);
            }
            test3()
        }
        test2()
    }
    test1()
```

# 12.隐式转化 
    var a = {}
    var b = {
        key: 'a'
    }
    var c = {
        key: 'c'
    }
    a[b] = '123'
    a[c] = '456'
    console.log(a[b]) //456
    //因为 var a = {}   ==》  a{
                                { key: 'a'}:'123'
                                { key: 'c'}:'456'
                              }
    对象的键会自动调用 toString方法 ==》 [Object Object]

# 13.上传文件的相关方法 
    由于原生的input 上传文件样式太丑，所以都是隐藏input ，同时自己添加一个按钮上传文件
    ```js
    input.style.display = 'none'
    //设置自己的上传元素点击事件，点击时触发上传
    mydom.addEventListener('click',()=>{
        input.click()
    })
    //监听 input 的 change 事件来对上传的文件进行操控
    ```
  ## 1.普通 前后都使用 formdata 格式进行上传
    ```js
    let formdata = new FormData()
    formdata.append('file',file) //添加key-value
    formdata.append('fileName',fileName) //添加key-value
    ```
    // 最后把 formdata 上传

  ## 2.使用 base64 上传（可以实现图片预览）
    ```js
    1.先读取文件成 base64格式
    let fileReader = new FileReader()
    fileReader.readAsDataURL()
    fileReader.onload=ev=>{
       base64 = ev.target.result 
    }
    2.通过 encodeURIComponent 对base64 进行编码，防止传输过程中出现乱码
    file: encodeURIComponent(base64)
    3.axios 发送请求时 设置 headers 为 application/x-www-form-urlencoded(后端也需要对接口做配合)
    ```
  
  ## 3.将文件读取成二进制数据并使用 MD5 加密
    ```js
    //需要下载 SparkMD5 库

    let fileReader = new FileReader();
    fileReader.readAsArrayBuffer(file)
    fileReader.onload=(ev) => {
        let buffer = ev.target.result
        let spark = new SparkMD5.ArrayBuffer()
        let HASH = spark.append(buffer)
        //取文件后缀
        let suffix =/\.([a-zA-Z0-9]+)$/.exec(file.name)[1]
        resolve({
            buffer,
            HASH,
            suffix,
            //将MD5加密后的文件名重新组合成新的文件名，防止文件传到服务端后会出现重名的导致上传失败
            filename:`${HASH}.${suffix}`
        })
    }
   
    
    ```

  ## 3.多文件上传可以给 input 标签添加 muplite 表示多文件，accept="image/gif, image/jpeg" 属性表示允许上传以什么格式的文件

  ## 4.拖拽上传可以使用 dragenter（拖拽进入） ， dragleave（拖拽离开），dragover(拖拽移动),drop（松开拖拽）。
给要拖拽上传的区域添加一个监听事件(addEventListener)：
    监听 dragover时 ev.preventDefault 取消默认事件。
    监听 drop事件时，ev.preventDefault 取消默认事件，并且 
    ```js
    let file = ev.dataTransfer.files[0]
    ```
    获取拖拽上传的文件




# 14.~~运算符
简单一点就是将一些变量转化为Number（数字）类型的；
·数字类型的字符串可以转化为纯数字
```js
var a='123'
console.log(~~a); //输出123

·字符串中带了其他字母，符号，或者其他除数字外的东西，一律输出 Number类型的0
var a='asd'

console.log(~~a); //输出0

·任何boolen类型的，如果为TRUE则输出1，FALSE输出0；
var a=1==1;
console.log(~~a);//输出1

·特殊类型，转化为Boolean是true的输出1，转化为boolean是false的输出0；
var a=undefined;
console.log(~~a);//输出0
var b=！undefined;
console.log(~~b);//输出1
```


# 15.前端性能检测 performance
![performance](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\performance(1).png)
![performance2](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\performance(2).png)
可以使用Navigation，timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下:
. DNS查询耗时= domainLookupEnd - domainLookupStart
. TCP链接耗时= connectEnd - connectStart
. request请求耗时= responseEnd - responseStart
· 解析dom树耗时= domComplete - domInteractive
· 白屏时间= domloadng - fetchStart
. domready时间= domContentLoadedEventEnd - fetchStart 
. onload时间= loadEventEnd - fetchStart

# 16.link标签引入css会阻塞dom渲染嘛
<link>标签不会阻塞DOM的解析；
<link>标签会阻塞DOM的渲染；
<link>标签同时还会阻塞其之后的<script>标签的执行。