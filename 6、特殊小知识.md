# 1.实现两个值的交换，而不必使用临时变量
使用异或
```
    let a = 3       //0011
    let b = 5       //0101

    a = a ^ b       //0011 ^ 0101 = 0110   6
    b = b ^ a       //0101 ^ 0110 = 0011   3
    a = a ^ b       //0110 ^ 0011 = 0101   5
    console.log(a); //5
    console.log(b); //3
```

# 2.数组push函数返回的是什么
    const a=[].push(3)  //a  1
    返回的是数组的长度

# 3.slice()和splice()区别
1.slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。

·注意：该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。

2.splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目或数字。（该方法会改变原数组）
```
splice（index,howmany,item1,...itemX）
    ·index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。
    ·howmany参数：必须，要删除的数量，如果为0，则不删除项目。
    ·tem1,...itemX参数：可选，向数组添加的新项目。
```

# 4.设计和实现一个  LRU (最近最少使用) 缓存机制。
```js
class LRU {
        //capacity :  缓存的容量
        constructor(capacity) {
            this.capacity = capacity;
            this.map = new Map()
        }
        /*
        *  get: 你每当获取即使了这个数，就将它从 map中移到最后，即代表最新使用，
        */
        get(key) {
            let val = this.map.get(key);
            if (val === "undefined") return -1;
            this.map.delete(key);
            this.map.set(key, val)
        }
        /*
        *  put: 第一步 如果 map 中已经存在这个数，就将它删除，
        *       第二步 将这个数储存到map中
        *       第三步 capacity为你设置的容量，判断 map 中储存的数量是否超过了容量，如果是则通过*       while循环 this.map.keys().next().value删除开头的值        
        */
        put(key, val) {
            if (this.map.has(key)) {
                this.map.delete(key);
            }
            this.map.set(key, val)
            let keys = this.map.keys()
            while (this.capacity < this.map.size) {
                this.map.delete(keys.next().value)
            }
        }
    }
```

# 5.获取全局对象
web:window.,this.,frames.
node:global
worker:self.
通用：globalThis

# 6. try catch 输出什么？
```js
    (() => {
            let x, y;
            try {
                throw new Error();
            } catch (x) {
                (x = 1), (y = 2);       //catch(x) 所以 第一个console在作用域中（x=1）为 1，第二个 y=2 是全局赋值
                console.log(x);
            }
            console.log(x);
            console.log(y);
        })();
```
输出：1 undefined 2

# 7. 这题考察的是对象的键名的转换。
对象的键名只能是字符串和 Symbol 类型。
其他类型的键名会被转换成字符串类型。
对象转字符串默认会调用 toString 方法。
```JS
// example 1
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]);
// c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉, 输出 c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]);      // 输出 b

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';       
a[c]='c';      
console.log(a[b]); 
// b 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。
// c 不是字符串也不是 Symbol 类型，需要转换成字符串。
// 对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。  
// 输出 c
```

# 8. 比较相等性
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}
checkAge({ age: 18 });  //Hmm.. You don't have an age I guess
```
在比较相等性，原始类型通过它们的值进行比较，而*对象通过它们的引用进行比较*。JavaScript检查对象是否具有对内存中相同位置的引用。
我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置，所以它们的引用是不同的。

# 9.下面代码中什么时候会输出1？
```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
     console.log(1);
}
```
```js
//因为==会进行隐式类型转换 所以我们重写toString方法就可以了
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
```

# 10.输出什么？小心作用域
```js
  let f = true
    if (f == true) {
        var a = 10
    }
    function fn() {
        var b = 20
        c = 30
    }
    fn()
    console.log(a);  //10
    console.log(b);  //Uncaught ReferenceError: b is not defined //因为function 是有作用域的，所以b在全局中找不到
    console.log(c);) //30
```


# 11.this指向
```js
 function test1() {
        var name = 'test1'
        function test2() {
            var name = 'test2'
            function test3() {
                var name = 'test3'
                console.log(this.name);
            }
            test3()
        }
        test2()
    }
    test1() //undefined 指向 window
```

# 12.隐式转化 
  ```js
    var a = {}
    var b = {
        key: 'a'
    }
    var c = {
        key: 'c'
    }
    a[b] = '123'
    a[c] = '456'
    console.log(a[b]) //456

    因为 var a = {} ==>a{
                        { key: 'a'}:'123'
                        { key: 'c'}:'456'
                    }
  ```
    对象的键会自动调用 toString方法 ==》 [Object Object]

# 13.上传文件的相关方法 
    由于原生的input 上传文件样式太丑，所以都是隐藏input ，同时自己添加一个按钮上传文件
    ```js
    input.style.display = 'none'
    //设置自己的上传元素点击事件，点击时触发上传
    mydom.addEventListener('click',()=>{
        input.click()
    })
    //监听 input 的 change 事件来对上传的文件进行操控
    ```
  ## 1.普通 前后都使用 formdata 格式进行上传
    ```js
    let formdata = new FormData()
    formdata.append('file',file) //添加key-value
    formdata.append('fileName',fileName) //添加key-value
    ```
    // 最后把 formdata 上传

  ## 2.使用 base64 上传（可以实现图片预览）
    ```js
    1.先读取文件成 base64格式
    let fileReader = new FileReader()
    fileReader.readAsDataURL()
    fileReader.onload=ev=>{
       base64 = ev.target.result 
    }
    2.通过 encodeURIComponent 对base64 进行编码，防止传输过程中出现乱码
    file: encodeURIComponent(base64)
    3.axios 发送请求时 设置 headers 为 application/x-www-form-urlencoded(后端也需要对接口做配合)
    ```
  
  ## 3.将文件读取成二进制数据并使用 MD5 加密
    ```js
    //需要下载 SparkMD5 库

    let fileReader = new FileReader();
    fileReader.readAsArrayBuffer(file)
    fileReader.onload=(ev) => {
        let buffer = ev.target.result
        let spark = new SparkMD5.ArrayBuffer()
        let HASH = spark.append(buffer)
        //取文件后缀
        let suffix =/\.([a-zA-Z0-9]+)$/.exec(file.name)[1]
        resolve({
            buffer,
            HASH,
            suffix,
            //将MD5加密后的文件名重新组合成新的文件名，防止文件传到服务端后会出现重名的导致上传失败
            filename:`${HASH}.${suffix}`
        })
    }
   
    
    ```

  ## 3.多文件上传可以给 input 标签添加 muplite 表示多文件，accept="image/gif, image/jpeg" 属性表示允许上传以什么格式的文件

  ## 4.拖拽上传可以使用 dragenter（拖拽进入） ， dragleave（拖拽离开），dragover(拖拽移动),drop（松开拖拽）。
给要拖拽上传的区域添加一个监听事件(addEventListener)：
    监听 dragover时 ev.preventDefault 取消默认事件。
    监听 drop事件时，ev.preventDefault 取消默认事件，并且 
    ```js
    let file = ev.dataTransfer.files[0]
    ```
    获取拖拽上传的文件




# 14.~~运算符
简单一点就是将一些变量转化为Number（数字）类型的；
·数字类型的字符串可以转化为纯数字
```js
var a='123'
console.log(~~a); //输出123

·字符串中带了其他字母，符号，或者其他除数字外的东西，一律输出 Number类型的0
var a='asd'

console.log(~~a); //输出0

·任何boolen类型的，如果为TRUE则输出1，FALSE输出0；
var a=1==1;
console.log(~~a);//输出1

·特殊类型，转化为Boolean是true的输出1，转化为boolean是false的输出0；
var a=undefined;
console.log(~~a);//输出0
var b=！undefined;
console.log(~~b);//输出1
```

# 15.link标签引入css会阻塞dom渲染嘛
<link>标签不会阻塞DOM的解析；
<link>标签会阻塞DOM的渲染；
<link>标签同时还会阻塞其之后的<script>标签的执行。

# 16.前端关于单点登录的知识
## 什么是单点登录
单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。

![单点登录](C:\Users\Lenovo\Desktop\JsVueReact复习\单点登录.png)
·用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
·sso认证中心发现用户未登录，将用户引导至登录页面
·用户输入用户名密码提交登录申请
·sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
·sso认证中心带着令牌跳转会最初的请求地址（系统1）
·系统1拿到令牌，去sso认证中心校验令牌是否有效
·sso认证中心校验令牌，返回有效，注册系统1
·系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
·用户访问系统2的受保护资源
·系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
·sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
·系统2拿到令牌，去sso认证中心校验令牌是否有效
·sso认证中心校验令牌，返回有效，注册系统2
·系统2使用该令牌创建与用户的局部会话，返回受保护资源

## 2.注销
sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。
·用户向系统1发起注销请求
·系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求
·sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址
·sso认证中心向所有注册系统发起注销请求
·各注册系统接收sso认证中心的注销请求，销毁局部会话
·sso认证中心引导用户至登录页面



# **100**.前端性能优化 （performance，DNS预查询，）
## performance（在浏览器F12打开或js的 API ）
![performance](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\performance(1).png)
![performance2](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\performance(2).png)
可以使用Navigation，timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下:
. DNS查询耗时= domainLookupEnd - domainLookupStart
. TCP链接耗时= connectEnd - connectStart
. request请求耗时= responseEnd - responseStart
· 解析dom树耗时= domComplete - domInteractive
· 白屏时间= domloadng - fetchStart
. domready时间= domContentLoadedEventEnd - fetchStart 
. onload时间= loadEventEnd - fetchStart

## DNS预查询（<link rel="dns-prefetch"）

DNS查询
与服务器交互首先要进行DNS查询，得到服务器的IP地址，浏览器会首先查询自己的缓存，之后会查询本地HOSTS，如果仍然没找到会发起向DNS服务器查询的请求。

进行DNS预查询
在文档顶部我们可以将我们即将要请求的地址的DNS预先查询，通过插入一个link标签

<link rel="dns-prefetch" href="https://fonts.googleapis.com/">

来告知浏览器我们将要从这个地址(通常会是存放静态资源的CDN的地址，)拉取数据了，你先查询一下，当用到的时候就可以直接拿到对应的IP。

## 建立HTTP(TCP)连接（缓存）
得到服务器IP之后，首先进行三次握手，之后会进行SSL握手(HTTPS)，SSL握手时会向服务器端确认HTTP的版本。

·keep-alive
由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了*Connection: Keep-Alive*，keep-alive的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生队头阻塞的问题。
HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。


### HTTP2
HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以并行传输而不被阻塞，这样就解决了HTTP1.1时复用会产生的队头阻塞的问题，同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。

HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。
![http缓存](C:\Users\Lenovo\Desktop\JsVueReact复习\photo\http缓存.png)
·强缓存
强缓存根据请求头的Expires和Cache-Control判断是否命中强缓存，命中强缓存的资源直接从本地加载，不会发起任何网络请求。
·协商缓存
协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。

## CDN
CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从最近的CDN服务器拿取资源而不是从源站拿取，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性。

## 进行页面渲染
预加载/预连接内容
可以将即将要用到的资源或者即将要握手的地址提前告知浏览器让浏览器利用还在解析HTML计算样式的时间去提前准备好。
### preload
使用link的preload属性预加载一个资源。
```js
<link rel="preload" href="style.css" as="style">
```
as属性可以指定预加载的类型，除了style还支持很多类型，常用的一般是style和script，css和js。

### prefetch
prefetch和preload差不多，prefetch是一个低优先级的获取，通常用在这个资源可能会在用户接下来访问的页面中出现的时候。
当然对当前页面的要用preload，不要用prefetch，可以用到的一个场景是在用户鼠标移入a标签时进行一个prefetch。


### preconnect
preconnect和dns-prefetch做的事情类似，提前进行TCP，SSL握手，省去这一部分时间，基于HTTP1.1(keep-alive)和HTTP2(多路复用)的特性，都会在同一个TCP链接内完成接下来的传输任务。

### script加标记
```js
<script src="main.js" async>

多条js可以并行下载，当js下载完成后会立即(尽快)执行，
多条js不会互相等待，下载期间浏览器会去干其他事(继续解析HTML等)，异步下载，异步执行。

defer标记
<script src="main.js" defer></script>
多条js可以并行下载，不过当js下载完成之后不会立即执行，而是会等待解析完整个HTML之后在开始执行。
多条defer标记的js会按照顺序执行，
```
两个标记都是为了让script标签实现异步下载，主要的区别在于：
async无法保证顺序且下载完就会执行而defer则会等待整个HTML解析之后才会开始执行，并且按照插入的顺序执行。


## 视窗外的内容懒加载
懒加载也是一个经常被提及的技术，视窗外的内容是不会被用户立即看到的，这时加载过多的内容反而拖慢了网站整体的渲染，我们就可以用懒加载推迟这部分内容的加载来达到加速可访问和可交互性的目的，等用户即将到达视窗内的时候再开始加载这部分内容，通常懒加载会与loading和骨架屏等技术搭配使用。

## 减少无意义的回流
回流与重绘是一个老生常谈的问题，当浏览器大小改变/滚动，DOM增删，元素尺寸或者位置发生改变时都会发生回流，回流意味着浏览器要重新计算当前页面的与之相关的所有元素，重新进行整体的布局。